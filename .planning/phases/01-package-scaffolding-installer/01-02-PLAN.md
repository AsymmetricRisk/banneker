---
phase: 01-package-scaffolding-installer
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/flags.js
  - lib/paths.js
  - test/flags.test.js
  - test/paths.test.js
autonomous: true

must_haves:
  truths:
    - "CLI flags are parsed correctly for all supported flags"
    - "Invalid flags produce clear error messages"
    - "Runtime install paths resolve correctly per runtime and scope"
    - "Mutual exclusion rules are enforced (multiple runtimes, global+local)"
  artifacts:
    - path: "lib/flags.js"
      provides: "Flag parsing with util.parseArgs"
      exports: ["parseFlags"]
    - path: "lib/paths.js"
      provides: "Install path resolution per runtime"
      exports: ["resolveInstallPaths"]
    - path: "test/flags.test.js"
      provides: "Flag parsing tests"
      contains: "describe.*parseFlags"
    - path: "test/paths.test.js"
      provides: "Path resolution tests"
      contains: "describe.*resolveInstallPaths"
  key_links:
    - from: "lib/flags.js"
      to: "node:util"
      via: "parseArgs import"
      pattern: "import.*parseArgs.*node:util"
    - from: "lib/paths.js"
      to: "node:os"
      via: "homedir import"
      pattern: "import.*os.*node:os"
---

<objective>
Build and test the flag parsing and path resolution modules using TDD.

Purpose: These are the core logic modules with defined inputs/outputs -- perfect TDD candidates. Flag parsing converts argv into structured options. Path resolution converts (runtime, scope) into filesystem paths. Both have clear contracts that tests can define upfront.
Output: Two tested, working modules: lib/flags.js and lib/paths.js
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-package-scaffolding-installer/01-RESEARCH.md
</context>

<feature>
  <name>Flag Parsing (lib/flags.js)</name>
  <files>lib/flags.js, test/flags.test.js</files>
  <behavior>
  parseFlags(argv) -> { runtime, scope, uninstall, help, error }

  Test cases:
  - `['--claude']` -> `{ runtime: 'claude', scope: null, uninstall: false, help: false, error: null }`
  - `['--opencode']` -> `{ runtime: 'opencode', scope: null, ... }`
  - `['--gemini']` -> `{ runtime: 'gemini', scope: null, ... }`
  - `['--claude', '--global']` -> `{ runtime: 'claude', scope: 'global', ... }`
  - `['--claude', '--local']` -> `{ runtime: 'claude', scope: 'local', ... }`
  - `['--uninstall', '--claude']` -> `{ runtime: 'claude', uninstall: true, ... }`
  - `['-c']` -> `{ runtime: 'claude', ... }` (short flags: -c, -o, -g, -u, -h)
  - `['--help']` -> `{ help: true, ... }`
  - `[]` (no args) -> `{ runtime: null, scope: null, uninstall: false, help: false, error: null }` (triggers interactive mode)
  - `['--claude', '--opencode']` -> `{ error: 'Cannot specify multiple runtimes' }`
  - `['--global', '--local']` -> `{ error: 'Cannot specify both --global and --local' }`
  - `['--unknown']` -> `{ error: ... }` (util.parseArgs strict mode error)

  The function accepts an argv array (NOT process.argv -- caller strips first 2 elements).
  Uses util.parseArgs with strict: true.
  Validates mutual exclusion: only one runtime flag, not both --global and --local.
  Returns a plain object, never throws.
  </behavior>
  <implementation>
  Use `import { parseArgs } from 'node:util'` with options config for all flags.
  Wrap parseArgs in try/catch (strict mode throws on unknown flags).
  After parsing, validate mutual exclusion rules.
  Return normalized result object.
  </implementation>
</feature>

<feature>
  <name>Path Resolution (lib/paths.js)</name>
  <files>lib/paths.js, test/paths.test.js</files>
  <behavior>
  resolveInstallPaths(runtime, scope) -> { commandsDir, configDir }

  Where:
  - runtime is 'claude' | 'opencode' | 'gemini'
  - scope is 'global' | 'local' | null (null defaults to 'global' for commands dir)

  Test cases (using mocked homedir '/home/testuser'):
  - `('claude', 'global')` -> `{ commandsDir: '/home/testuser/.claude/commands', configDir: '/home/testuser/.claude' }`
  - `('claude', 'local')` -> `{ commandsDir: '.claude/commands', configDir: '.claude' }` (relative to cwd)
  - `('opencode', 'global')` -> `{ commandsDir: '/home/testuser/.opencode/commands', configDir: '/home/testuser/.opencode' }`
  - `('gemini', 'global')` -> `{ commandsDir: '/home/testuser/.gemini/commands', configDir: '/home/testuser/.gemini' }`
  - `('claude', null)` -> same as `('claude', 'global')` (default scope)
  - Invalid runtime -> throws Error

  The function takes an optional `homeDir` parameter for testability (defaults to os.homedir()).
  Uses path.join for all path construction (cross-platform).
  </behavior>
  <implementation>
  Import RUNTIMES from constants.js (or define inline if constants not yet available -- but Plan 01 runs in parallel, so import from constants.js and handle gracefully).

  Actually, since this is Wave 1 parallel with Plan 01, define the runtime path mappings inline in paths.js rather than importing from constants.js. Plan 03 can consolidate if needed.

  For 'global' scope: join homeDir + runtime path.
  For 'local' scope: use relative paths (cwd-relative).
  For null scope: default to 'global'.
  </implementation>
</feature>

<verification>
- `node --test test/flags.test.js` -- all tests pass
- `node --test test/paths.test.js` -- all tests pass
- Both modules use only Node.js built-in imports (node:util, node:os, node:path)
- No third-party dependencies added
</verification>

<success_criteria>
Both lib/flags.js and lib/paths.js exist with full test coverage. All flag combinations parse correctly. All runtime/scope combinations resolve to correct paths. Mutual exclusion validation works. Tests prove the contract.
</success_criteria>

<output>
After completion, create `.planning/phases/01-package-scaffolding-installer/01-02-SUMMARY.md`
</output>
