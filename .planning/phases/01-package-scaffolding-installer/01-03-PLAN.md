---
phase: 01-package-scaffolding-installer
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - lib/prompts.js
  - lib/installer.js
  - lib/uninstaller.js
autonomous: true

must_haves:
  truths:
    - "Running with --claude --global installs files without prompts"
    - "Running with no flags triggers interactive runtime selection"
    - "Existing VERSION file triggers overwrite confirmation prompt"
    - "Running with --uninstall --claude removes only Banneker files"
    - "SIGINT during prompts exits cleanly"
  artifacts:
    - path: "lib/prompts.js"
      provides: "Interactive prompts for runtime selection and overwrite confirmation"
      exports: ["promptForRuntime", "promptForScope", "promptForOverwrite"]
    - path: "lib/installer.js"
      provides: "Main installer orchestration"
      exports: ["run"]
    - path: "lib/uninstaller.js"
      provides: "Safe uninstall logic"
      exports: ["uninstall"]
  key_links:
    - from: "lib/installer.js"
      to: "lib/flags.js"
      via: "import parseFlags"
      pattern: "import.*parseFlags.*flags"
    - from: "lib/installer.js"
      to: "lib/paths.js"
      via: "import resolveInstallPaths"
      pattern: "import.*resolveInstallPaths.*paths"
    - from: "lib/installer.js"
      to: "lib/prompts.js"
      via: "import prompt functions"
      pattern: "import.*prompt.*prompts"
    - from: "lib/installer.js"
      to: "lib/uninstaller.js"
      via: "conditional import for --uninstall"
      pattern: "import.*uninstall"
    - from: "bin/banneker.js"
      to: "lib/installer.js"
      via: "dynamic import"
      pattern: "import.*installer"
---

<objective>
Build the interactive prompts, installer orchestration, and uninstaller -- wiring together flag parsing and path resolution from Plan 02 with file operations.

Purpose: This is the core installer logic that makes `npx banneker` actually work. It connects the tested modules (flags, paths) with interactive prompts and filesystem operations.
Output: Three modules (prompts.js, installer.js, uninstaller.js) that together implement the full install/uninstall flow.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-package-scaffolding-installer/01-RESEARCH.md
@.planning/phases/01-package-scaffolding-installer/01-01-SUMMARY.md
@.planning/phases/01-package-scaffolding-installer/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create interactive prompts module</name>
  <files>lib/prompts.js</files>
  <action>
Create `lib/prompts.js` with three exported async functions using `node:readline/promises`:

1. **promptForRuntime()** -> returns 'claude' | 'opencode' | 'gemini'
   - Display numbered menu: "Select target runtime:\n  1) Claude Code\n  2) OpenCode\n  3) Gemini"
   - Accept input "1", "2", or "3"
   - Validate input, re-prompt on invalid choice (up to 3 attempts, then exit with error)
   - Map: 1->claude, 2->opencode, 3->gemini

2. **promptForScope()** -> returns 'global' | 'local'
   - Display: "Install location:\n  1) Global (~/.{runtime}/commands)\n  2) Local (.{runtime}/commands in current directory)"
   - Accept "1" or "2", validate, re-prompt on invalid
   - Map: 1->global, 2->local

3. **promptForOverwrite(existingVersion)** -> returns boolean
   - Display: "Found existing Banneker installation (v{existingVersion}). Overwrite? (y/N): "
   - Default to N (any input except 'y' or 'Y' returns false)

All functions:
- Create readline interface at start, close in finally block
- Use `{ input: process.stdin, output: process.stdout }` from `node:process`
- Handle readline 'close' event (Ctrl-D) gracefully by returning null
- Do NOT add SIGINT handler here (already in bin/banneker.js)
- Use `node:` prefix for all imports
  </action>
  <verify>
`node -e "import('./lib/prompts.js').then(m => console.log(Object.keys(m).sort().join(',')))"` outputs: `promptForOverwrite,promptForRuntime,promptForScope`
  </verify>
  <done>lib/prompts.js exports three async prompt functions that use readline/promises, handle invalid input with re-prompts, and clean up readline interface</done>
</task>

<task type="auto">
  <name>Task 2: Create installer orchestration and uninstaller</name>
  <files>lib/installer.js, lib/uninstaller.js</files>
  <action>
Create two modules that wire everything together:

**lib/uninstaller.js** -- exports `async function uninstall(commandsDir, configDir)`:
- Check for VERSION file in commandsDir. If not found, print "No Banneker installation found at {commandsDir}" and return false.
- Read BANNEKER_FILES from constants.js (or use inline list for now: just 'VERSION' plus any .md files in the directory that match known Banneker patterns).
- For each file in the manifest: check existence, remove with fs.rmSync if exists, count removals.
- Print summary: "Removed {N} Banneker files from {commandsDir}"
- Return true on success.
- Catch EACCES/EPERM errors and print helpful message about permissions.

**lib/installer.js** -- exports `async function run()`:
- This is the main entry point called by bin/banneker.js.
- Flow:
  1. Parse flags: `const flags = parseFlags(process.argv.slice(2))`
  2. If flags.error: print error, print usage hint, set process.exitCode=1, return
  3. If flags.help: print help text (usage, flags, examples), return
  4. Determine runtime: use flags.runtime if set, otherwise call promptForRuntime()
  5. Determine scope: use flags.scope if set, otherwise default to 'global' (do NOT prompt for scope unless neither --global nor --local was passed AND this is interactive mode -- actually, default to 'global' for simplicity per REQ-INST-006)
  6. Resolve paths: `const { commandsDir, configDir } = resolveInstallPaths(runtime, scope)`
  7. If flags.uninstall: call uninstall(commandsDir, configDir), return
  8. Check for existing install: look for VERSION file in commandsDir
     - If exists: read version, call promptForOverwrite(version)
     - If user declines: print "Installation cancelled.", return
  9. Create commandsDir with fs.mkdirSync({ recursive: true })
  10. Copy template files: use fs.cpSync from templates/commands/ to commandsDir (recursive: true)
  11. Copy VERSION file to commandsDir
  12. Print success: "Banneker v{VERSION} installed to {commandsDir}"

Help text should include:
```
Banneker - Project planning pipeline for AI coding assistants

Usage: npx banneker [options]

Options:
  -c, --claude      Install for Claude Code
  -o, --opencode    Install for OpenCode
  -g, --gemini      Install for Gemini
      --global      Install to home directory (default)
      --local       Install to current directory
  -u, --uninstall   Remove Banneker files
  -h, --help        Show this help message

Examples:
  npx banneker                    Interactive installation
  npx banneker --claude --global  Non-interactive Claude Code install
  npx banneker --uninstall -c     Remove Claude Code installation
```

Use `node:` prefix for all built-in imports. Import parseFlags from './flags.js', resolveInstallPaths from './paths.js', prompt functions from './prompts.js', VERSION from './constants.js'.

For file copy: use fs.cpSync with `{ recursive: true, force: true }` ONLY after overwrite confirmation. Use fs.writeFileSync to write VERSION file content to the target VERSION file.

Handle the case where templates/commands/ is empty (Phase 1 only has .gitkeep) -- this is fine, just create the directory and write VERSION.
  </action>
  <verify>
Run from project root:
1. `node bin/banneker.js --help` -- should print help text and exit 0
2. `node bin/banneker.js --claude --opencode` -- should print error about multiple runtimes and exit 1
3. `node bin/banneker.js --claude --global` -- should install to ~/.claude/commands/ (creates dir, copies VERSION)
4. `node bin/banneker.js --uninstall --claude --global` -- should remove Banneker files from ~/.claude/commands/
5. Verify no third-party imports in any lib/ file: `grep -r "from '" lib/ | grep -v "node:" | grep -v "from '\.\/"` should return empty
  </verify>
  <done>
- `node bin/banneker.js --help` prints usage and exits cleanly
- `node bin/banneker.js --claude --global` creates target directory, copies templates + VERSION file, prints success
- `node bin/banneker.js --uninstall --claude` removes only Banneker files
- Running again after install detects existing VERSION and prompts for overwrite
- Invalid flag combinations produce clear error messages
- Zero third-party imports in all lib/ files
  </done>
</task>

</tasks>

<verification>
- `node bin/banneker.js --help` exits 0 with usage text
- `node bin/banneker.js --claude --global` installs successfully to ~/.claude/commands/
- `cat ~/.claude/commands/VERSION` shows `0.2.0`
- `node bin/banneker.js --claude --global` again prompts for overwrite (VERSION detected)
- `node bin/banneker.js --uninstall --claude --global` removes Banneker files
- `node bin/banneker.js --global --local` shows mutual exclusion error
- All existing tests still pass: `node --test test/*.test.js`
- `grep -rn "require(" lib/ bin/` returns nothing (ES modules only)
</verification>

<success_criteria>
The complete installer flow works end-to-end: flags parsed, paths resolved, prompts shown when needed, files copied, VERSION written, uninstall removes only owned files. All seven phase requirements (REQ-INST-001 through REQ-INST-007) are addressed.
</success_criteria>

<output>
After completion, create `.planning/phases/01-package-scaffolding-installer/01-03-SUMMARY.md`
</output>
