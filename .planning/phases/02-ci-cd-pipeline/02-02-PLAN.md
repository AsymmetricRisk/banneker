---
phase: 02-ci-cd-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - test/unit/installer-permissions.test.js
  - test/integration/skill-validation.test.js
  - test/smoke/full-install.test.js
  - lib/installer.js
autonomous: true

must_haves:
  truths:
    - "Installer checks file permissions before writing to target directory"
    - "Installer prompts before overwriting existing files"
    - "Integration tests validate skill file YAML frontmatter has required fields"
    - "Smoke test runs full install in clean temp directory and verifies all files exist"
  artifacts:
    - path: "test/unit/installer-permissions.test.js"
      provides: "Permission check and overwrite prompt unit tests"
      contains: "EACCES"
    - path: "test/integration/skill-validation.test.js"
      provides: "YAML frontmatter validation tests for skill files"
      contains: "frontmatter"
    - path: "test/smoke/full-install.test.js"
      provides: "End-to-end install verification in temp directory"
      contains: "mkdtemp"
    - path: "lib/installer.js"
      provides: "Permission check before file writes (REQ-SEC-001)"
      contains: "accessSync"
  key_links:
    - from: "test/unit/installer-permissions.test.js"
      to: "lib/installer.js"
      via: "import and test permission checking"
      pattern: "import.*installer"
    - from: "test/smoke/full-install.test.js"
      to: "lib/installer.js"
      via: "runs full install flow against temp directory"
      pattern: "run\\("
    - from: "lib/installer.js"
      to: "node:fs"
      via: "accessSync permission check before mkdirSync/writeFileSync"
      pattern: "accessSync.*W_OK"
---

<objective>
Write the new tests required by REQ-CICD-003 and REQ-CICD-004 (unit tests for permission checks, integration tests for YAML frontmatter, smoke tests for full install), and add the permission-check logic to installer.js required by REQ-SEC-001 and REQ-SEC-002.

Purpose: The CI pipeline needs comprehensive test coverage. REQ-SEC-001 requires permission checks before writing to ~/.claude/. REQ-SEC-002 requires prompting before overwriting (already implemented via promptForOverwrite, needs test coverage). REQ-CICD-004 requires 100% coverage of installer file-write code paths.

Output: Three new test files covering all requirements, enhanced installer.js with explicit permission checking.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ci-cd-pipeline/02-RESEARCH.md

@lib/installer.js
@lib/constants.js
@lib/paths.js
@lib/flags.js
@lib/prompts.js
@lib/uninstaller.js
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add permission check to installer and write permission/overwrite tests</name>
  <files>
    lib/installer.js
    test/unit/installer-permissions.test.js
  </files>
  <action>
    1. Enhance lib/installer.js to check file permissions BEFORE writing (REQ-SEC-001):
       - Before the `mkdirSync(commandsDir, ...)` call, add an explicit permission check on the parent directory using `accessSync` with `constants.W_OK` from `node:fs`.
       - If the parent directory does not exist, walk up until finding an existing ancestor and check write permission on that.
       - On EACCES/EPERM, print a clear error message and set process.exitCode = 1.
       - Import `accessSync` and `constants as fsConstants` from 'node:fs'.

    2. Create test/unit/installer-permissions.test.js with tests for:
       - Permission check catches EACCES when target directory is not writable (mock accessSync to throw EACCES)
       - Permission check passes when directory is writable
       - Overwrite prompt is called when VERSION file exists (REQ-SEC-002 coverage)
       - Overwrite prompt declined cancels installation
       - EACCES on writeFileSync for VERSION file is handled gracefully

    Use node:test with `describe`, `it`, `mock` from 'node:test' and `assert` from 'node:assert/strict'.

    For mocking filesystem operations: use `t.mock.method()` on the fs module or use the approach from existing test/integration/installer.test.js (check how it handles mocking).

    Important: The installer's `run()` function reads `process.argv` directly. For unit testing specific code paths, consider extracting a testable function like `installFiles({ runtime, scope, homeDir, force })` that run() delegates to, OR test by mocking at the filesystem level. Check the existing installer.test.js for the established pattern.
  </action>
  <verify>node --test test/unit/installer-permissions.test.js passes with all tests green</verify>
  <done>installer.js checks permissions before writing (REQ-SEC-001), tests verify permission checks and overwrite prompts (REQ-SEC-002)</done>
</task>

<task type="auto">
  <name>Task 2: Create integration test for YAML frontmatter and smoke test for full install</name>
  <files>
    test/integration/skill-validation.test.js
    test/smoke/full-install.test.js
  </files>
  <action>
    1. Create test/integration/skill-validation.test.js:
       - Read all .md files from templates/commands/ directory (the skill files that get installed)
       - For each file, verify it starts with YAML frontmatter (--- delimiter)
       - Parse frontmatter and assert required fields exist: `name`, `description`
       - Assert frontmatter ends with closing --- delimiter
       - Use node:fs/promises readdir + readFile
       - Use node:path join to build paths relative to project root
       - Get project root via: `join(dirname(fileURLToPath(import.meta.url)), '..', '..')`

    2. Create test/smoke/full-install.test.js:
       - Create a temporary directory via `mkdtemp(join(tmpdir(), 'banneker-smoke-'))`
       - Run the installer programmatically against the temp directory
       - The installer.js `run()` reads process.argv -- for smoke testing, either:
         a. Use child_process.execFile to invoke `node bin/banneker.js --claude --global` with HOME env var set to tempdir, OR
         b. Import and call a lower-level install function if one exists
       - Check the approach used in existing test/integration/installer.test.js and follow same pattern
       - After install, verify:
         - The runtime-specific commands directory exists (e.g., .claude/commands/ for Claude Code)
         - At least one .md file exists in the commands directory
         - VERSION file exists and contains the current version string
         - BANNEKER_FILES manifest exists (if the installer creates one)
       - Clean up temp directory in after() hook
       - Use `{ force: true, recursive: true }` in rm() for cleanup

    Important: Smoke tests should be self-contained and not depend on any global state. They create their own temp environment, run the installer, verify results, and clean up.
  </action>
  <verify>
    node --test test/integration/skill-validation.test.js passes.
    node --test test/smoke/full-install.test.js passes.
    npm test passes (all test tiers together).
  </verify>
  <done>YAML frontmatter validation tests pass for all skill files, smoke test verifies full install lifecycle in clean temp directory</done>
</task>

</tasks>

<verification>
1. `npm test` runs all tests including new ones, all pass
2. `npm run test:coverage-strict` shows improved coverage on lib/installer.js
3. Permission check in installer.js prevents writes to non-writable directories
4. All skill template files have valid YAML frontmatter with name and description
5. Smoke test creates temp dir, installs, verifies files, cleans up
</verification>

<success_criteria>
- installer.js has explicit accessSync permission check before file writes (REQ-SEC-001)
- Unit tests cover permission denied, permission granted, overwrite prompt paths
- Integration tests validate every skill file's YAML frontmatter
- Smoke test does full install in temp dir and verifies all expected files exist
- All tests pass: npm test exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/02-ci-cd-pipeline/02-02-SUMMARY.md`
</output>
