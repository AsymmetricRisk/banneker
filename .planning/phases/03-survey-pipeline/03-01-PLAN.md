---
phase: 03-survey-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - templates/agents/banneker-surveyor.md
  - schemas/survey.schema.json
  - schemas/architecture-decisions.schema.json
autonomous: true

must_haves:
  truths:
    - "Surveyor agent contains instructions for all 6 interview phases"
    - "Each phase has clear questions, completion criteria, and transition logic"
    - "State file write instructions are present for resume capability"
    - "JSON output instructions reference the schema files"
    - "Decision capture happens throughout interview, not just decision gate"
  artifacts:
    - path: "templates/agents/banneker-surveyor.md"
      provides: "Sub-agent definition for conducting 6-phase interview"
      contains: "pitch.*actors.*walkthroughs.*backend.*gaps.*decision"
      min_lines: 150
    - path: "schemas/survey.schema.json"
      provides: "Reference JSON Schema for survey.json output"
      contains: "survey_metadata"
    - path: "schemas/architecture-decisions.schema.json"
      provides: "Reference JSON Schema for architecture-decisions.json output"
      contains: "DEC-"
  key_links:
    - from: "templates/agents/banneker-surveyor.md"
      to: "schemas/survey.schema.json"
      via: "schema reference in output instructions"
      pattern: "survey\\.schema\\.json"
    - from: "templates/agents/banneker-surveyor.md"
      to: ".banneker/state/survey-state.md"
      via: "state file write instructions"
      pattern: "survey-state\\.md"
---

<objective>
Create the banneker-surveyor sub-agent and JSON reference schemas that define the 6-phase structured discovery interview.

Purpose: The surveyor agent is the "brain" of the survey pipeline. It conducts the actual interview, manages state, and produces structured JSON output. The schemas define the exact structure of survey.json and architecture-decisions.json for downstream consumption.

Output: Three files -- the surveyor agent markdown and two JSON Schema reference files.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-survey-pipeline/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JSON reference schemas for survey output</name>
  <files>schemas/survey.schema.json, schemas/architecture-decisions.schema.json</files>
  <action>
Create the `schemas/` directory at project root.

Create `schemas/survey.schema.json` -- a JSON Schema (draft-2020-12) defining the structure of `.banneker/survey.json`. This is a REFERENCE schema (not used for runtime validation due to zero-dependency constraint). Structure must match the research findings:

```json
{
  "survey_metadata": { "version": "string", "created": "ISO8601", "runtime": "string" },
  "project": { "name": "string", "one_liner": "string", "problem": "string" },
  "actors": [{ "name": "string", "type": "human|system", "role": "string", "capabilities": ["string"] }],
  "walkthroughs": [{
    "name": "string", "type": "primary|secondary|error",
    "steps": ["string"], "system_responses": ["string"],
    "data_changes": ["string"], "error_cases": ["string"]
  }],
  "backend": {
    "data_stores": ["string"], "integrations": ["string"],
    "infrastructure": ["string"],
    "applicable": "boolean (false for frontend-only/static projects)"
  },
  "rubric_coverage": { "covered": ["string"], "gaps": ["string"] }
}
```

Use snake_case for all keys (per research recommendation for Python ecosystem compatibility).

Create `schemas/architecture-decisions.schema.json` -- JSON Schema for `.banneker/architecture-decisions.json`:

```json
{
  "decisions": [{
    "id": "DEC-NNN format",
    "question": "string",
    "choice": "string",
    "rationale": "string",
    "alternatives_considered": [{
      "option": "string",
      "rejected_because": "string"
    }],
    "phase": "string (which interview phase captured this)",
    "timestamp": "ISO8601"
  }]
}
```

Both schemas should have proper `$schema`, `title`, `description`, and `required` fields. Mark all top-level keys as required in survey.schema.json. Mark `id`, `question`, `choice`, `rationale` as required in each decision entry.
  </action>
  <verify>
Validate both files parse as valid JSON:
```bash
node -e "JSON.parse(require('fs').readFileSync('schemas/survey.schema.json','utf8')); console.log('survey schema: valid')"
node -e "JSON.parse(require('fs').readFileSync('schemas/architecture-decisions.schema.json','utf8')); console.log('decisions schema: valid')"
```
  </verify>
  <done>Both schema files exist, parse as valid JSON, and define the complete structure for survey.json and architecture-decisions.json with all required fields documented.</done>
</task>

<task type="auto">
  <name>Task 2: Create the banneker-surveyor sub-agent</name>
  <files>templates/agents/banneker-surveyor.md</files>
  <action>
Create the `templates/agents/` directory.

Create `templates/agents/banneker-surveyor.md` -- the sub-agent that conducts the 6-phase structured discovery interview. This is an Agent Skills format file (YAML frontmatter + Markdown instructions).

**Frontmatter:**
```yaml
---
name: banneker-surveyor
description: "Sub-agent that conducts a 6-phase structured discovery interview, producing survey.json and architecture-decisions.json. Manages state for resume capability."
---
```

**Content structure (this is the critical part -- these are the agent's instructions):**

1. **Role Statement:** "You are the Banneker Surveyor. You conduct structured discovery interviews to understand a software project..."

2. **Output Files:** List the 3 files this agent manages:
   - `.banneker/survey.json` (final structured output)
   - `.banneker/architecture-decisions.json` (decision records)
   - `.banneker/state/survey-state.md` (resume state -- cleared on completion)

3. **State Management Protocol:**
   - After EACH question answered, update `.banneker/state/survey-state.md`
   - State file format: Markdown with sections for Current Phase, Completed Phases, Collected Data, Next Steps, Interview Metadata
   - On completion, write final JSON files then delete state file
   - Use the state file format from 03-RESEARCH.md Pattern 2

4. **Phase 1: Pitch** (order: 1)
   - Questions: project name, one-liner description, problem statement, target users
   - Also ask: "Does this project have a backend?" (for Phase 4 skip logic)
   - Completion: All questions answered
   - Confirm collected data with user before proceeding

5. **Phase 2: Actors** (order: 2)
   - Questions: Who/what interacts with the system? For each: name, type (human/system), role, capabilities
   - Minimum: 2 actors defined
   - Completion: User confirms actor list is complete
   - Watch for implicit architecture decisions -- flag them for DEC-XXX

6. **Phase 3: Walkthroughs** (order: 3)
   - For each key user flow: name, type (primary/secondary/error), steps, system responses, data changes, error cases
   - Minimum: 1 walkthrough (primary happy path)
   - Guide user through step-by-step: "What happens next? What does the system do?"
   - Watch for implicit architecture decisions

7. **Phase 4: Backend** (order: 4)
   - If Phase 1 flagged "no backend": skip, write `"backend": {"applicable": false}` in survey.json
   - Otherwise: data stores, integrations, infrastructure choices
   - Watch for implicit architecture decisions

8. **Phase 5: Gaps** (order: 5)
   - Review rubric coverage: which categories are covered by collected data?
   - Identify gaps: what hasn't been discussed?
   - Ask targeted questions to fill gaps
   - Categories: roles/actors, data model, API surface, auth, infrastructure, error handling, testing strategy

9. **Phase 6: Decision Gate** (order: 6)
   - Review all phases for architecture decisions made (implicit or explicit)
   - For each: create DEC-XXX entry with question, choice, rationale, alternatives
   - Prompt: "Let me review what we discussed. I noticed these technology/architecture choices..."
   - User confirms each decision record

10. **Completion Protocol:**
    - Build survey.json matching the schema structure exactly (reference schemas/survey.schema.json)
    - Build architecture-decisions.json
    - Write both files to `.banneker/` directory
    - Read back each file and verify it parses with JSON.parse()
    - Delete `.banneker/state/survey-state.md` on success
    - Report: "Survey complete. Files written: [paths]"

11. **JSON Output Quality Rules:**
    - Use JSON.stringify() semantics: no trailing commas, escape all quotes
    - All string values must be non-empty
    - Arrays must have at least the minimum entries (2 actors, 1 walkthrough)
    - Include survey_metadata with version "1.0", created timestamp, runtime name

Important constraints to embed in agent instructions:
- Keep only current phase questions in active conversation; externalize completed phase data to state file
- When resuming, read state file and show user what was already collected
- Adapt questions based on prior answers (don't ask backend questions for static sites)
- Be conversational, not interrogative -- guide rather than quiz
  </action>
  <verify>
Verify the file exists and has proper Agent Skills frontmatter:
```bash
head -5 templates/agents/banneker-surveyor.md
```
Should show YAML frontmatter with `name: banneker-surveyor` and `description`.

Verify all 6 phases are mentioned:
```bash
grep -c "Phase [1-6]" templates/agents/banneker-surveyor.md
```
Should return 6 or more.

Verify state management instructions exist:
```bash
grep -c "survey-state.md" templates/agents/banneker-surveyor.md
```
Should return 3 or more references.
  </verify>
  <done>banneker-surveyor.md exists with Agent Skills frontmatter, contains instructions for all 6 interview phases (pitch, actors, walkthroughs, backend, gaps, decision gate), includes state management for resume, includes JSON output instructions referencing the schema files, and includes decision capture throughout the interview.</done>
</task>

</tasks>

<verification>
1. `schemas/survey.schema.json` parses as valid JSON and contains all required top-level keys
2. `schemas/architecture-decisions.schema.json` parses as valid JSON with DEC-XXX format
3. `templates/agents/banneker-surveyor.md` has Agent Skills frontmatter
4. Surveyor references all 6 phases with clear transition logic
5. State file management instructions are comprehensive (write after each question, clear on completion)
6. JSON output instructions reference schema files
</verification>

<success_criteria>
- Three new files created: surveyor agent, survey schema, decisions schema
- Surveyor agent is a complete, self-contained set of instructions that could guide an AI through the full interview
- Schemas define exact structure matching research findings with snake_case keys
- Resume capability fully specified in surveyor instructions
</success_criteria>

<output>
After completion, create `.planning/phases/03-survey-pipeline/03-01-SUMMARY.md`
</output>
