---
phase: 08-brownfield-analysis-audit
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - templates/commands/banneker-document.md
  - templates/commands/banneker-audit.md
autonomous: true

must_haves:
  truths:
    - "/banneker:document command spawns cartographer and manages codebase analysis lifecycle"
    - "/banneker:audit command spawns auditor and manages plan evaluation lifecycle"
    - "Both commands detect existing output and offer resume/overwrite"
    - "Both commands verify completion before reporting success"
  artifacts:
    - path: "templates/commands/banneker-document.md"
      provides: "Cartographer orchestrator with prerequisite checks and resume detection"
      contains: "banneker-document"
    - path: "templates/commands/banneker-audit.md"
      provides: "Auditor orchestrator with prerequisite checks and completion verification"
      contains: "banneker-audit"
  key_links:
    - from: "templates/commands/banneker-document.md"
      to: "templates/agents/banneker-cartographer.md"
      via: "command spawns agent via Task tool"
      pattern: "banneker-cartographer"
    - from: "templates/commands/banneker-audit.md"
      to: "templates/agents/banneker-auditor.md"
      via: "command spawns agent via Task tool"
      pattern: "banneker-auditor"
    - from: "templates/commands/banneker-audit.md"
      to: "templates/config/completeness-rubric.md"
      via: "command tells auditor where rubric config lives"
      pattern: "completeness-rubric"
---

<objective>
Create the two command orchestrator skill files for `/banneker:document` and `/banneker:audit`.

Purpose: Command files are the user-facing entry points. They handle lifecycle management (prerequisite checks, resume detection, spawning sub-agents, completion verification) while delegating the actual work to sub-agents. This follows the established pattern from banneker-survey.md, banneker-architect.md, banneker-feed.md, etc.

Output: `templates/commands/banneker-document.md` and `templates/commands/banneker-audit.md`
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-brownfield-analysis-audit/08-RESEARCH.md

# Reference existing command files for pattern consistency
@templates/commands/banneker-feed.md
@templates/commands/banneker-architect.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create document command orchestrator</name>
  <files>templates/commands/banneker-document.md</files>
  <action>
Create `templates/commands/banneker-document.md` following the established command file pattern (see banneker-feed.md and banneker-architect.md for structure).

**YAML frontmatter:**
```yaml
---
name: banneker-document
description: "Analyze an existing codebase to produce structured understanding. Scans file trees, identifies technologies, patterns, and architecture. Produces .banneker/codebase-understanding.md for brownfield project onboarding."
---
```

**Command body - follow the exact lifecycle pattern from banneker-feed.md:**

**Step 0: Prerequisite Check (MANDATORY)**
- Unlike survey/architect/feed commands, the document command does NOT require survey.json or architecture-decisions.json
- The document command works on raw codebases with no prior Banneker state
- Only prerequisite: current directory must contain source files (check for at least one of: package.json, Cargo.toml, pyproject.toml, go.mod, Makefile, pom.xml, build.gradle, *.sln, or any src/ directory)
- If no project indicators found: display "No project detected in current directory. Run this command from a project root." and abort

**Step 1: Resume Detection**
Three resume conditions to check (in order):

1. **Interrupted scan** - `.banneker/state/document-state.md` exists
   - Display: "Previous codebase analysis was interrupted. Resume from where it left off?"
   - Options: resume (continue from state), restart (delete state and start fresh)

2. **Existing analysis** - `.banneker/codebase-understanding.md` exists
   - Display: "Existing codebase analysis found (created [date from file])."
   - Options: overwrite (replace), keep (abort with message "Existing analysis preserved")

3. **Fresh start** - Neither file exists. Proceed to Step 2.

**Step 2: Spawn Cartographer**
- Use the Task tool to spawn the banneker-cartographer agent
- Pass context: working directory path, any resume state
- The cartographer handles all scanning and document generation

**Step 3: Completion Verification**
- Check `.banneker/codebase-understanding.md` exists and has content (not empty)
- Check `.banneker/state/document-state.md` does NOT exist (cleaned up = complete)
- If codebase-understanding.md exists but state file also exists: partial completion (context exhaustion)
  - Display: "Codebase analysis partially complete. Run /banneker:document again to resume."
- If codebase-understanding.md exists and no state file: full completion
  - Display: "Codebase analysis complete. See .banneker/codebase-understanding.md"
- If neither exists: failure
  - Display: "Codebase analysis failed. Check for errors above."
  </action>
  <verify>
1. File exists at templates/commands/banneker-document.md
2. File starts with valid YAML frontmatter (name: banneker-document)
3. File contains Steps 0-3 matching the lifecycle pattern
4. Step 0 checks for project indicators (not survey.json)
5. Step 1 handles all 3 resume conditions
6. Step 2 spawns banneker-cartographer agent
7. Step 3 verifies both output file and state file cleanup
  </verify>
  <done>
templates/commands/banneker-document.md exists with valid frontmatter, follows established command lifecycle pattern, does NOT require survey.json (works on raw codebases), handles 3 resume conditions, spawns cartographer agent, and verifies completion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audit command orchestrator</name>
  <files>templates/commands/banneker-audit.md</files>
  <action>
Create `templates/commands/banneker-audit.md` following the established command file pattern.

**YAML frontmatter:**
```yaml
---
name: banneker-audit
description: "Evaluate engineering plans against the completeness rubric. Reads plan files, scores 10 categories, identifies gaps, and produces coverage reports. Run on any project with .planning/ directory or plan files."
---
```

**Command body - follow the exact lifecycle pattern:**

**Step 0: Prerequisite Check (MANDATORY)**
- Check for plan files to audit. Look for:
  1. `.planning/phases/` directory with PLAN.md files (GSD-style projects)
  2. `.banneker/` directory with generated documents (Banneker projects)
  3. Any .md files matching *PLAN* or *plan* pattern in current directory
- If no plan files found: display "No plan files found. This command evaluates engineering plans against a completeness rubric. Provide a project with .planning/ or plan files." and abort
- List discovered plan files to user: "Found N plan files to audit: [list]"

**Step 1: Resume Detection**
Two resume conditions:

1. **Existing audit report** - `.banneker/audit-report.json` exists
   - Display: "Previous audit report found (created [date]). Re-run audit with current plans?"
   - Options: re-audit (overwrite), keep (abort with "Existing audit preserved")

2. **Fresh audit** - No existing report. Proceed to Step 2.

**Step 2: Spawn Auditor**
- Use the Task tool to spawn the banneker-auditor agent
- Pass context: list of plan file paths to audit, path to completeness-rubric.md config
- If ROADMAP.md exists, pass its path too (for dependency-aware scoring)

**Step 3: Completion Verification**
- Check `.banneker/audit-report.json` exists and is valid JSON
- Check `.banneker/audit-report.md` exists and has content
- If both exist:
  - Read overall grade from JSON
  - Display: "Audit complete. Grade: [grade] ([percentage]%). See .banneker/audit-report.md for details."
  - If grade is C or below: "N gaps found. Run /banneker:audit to see recommendations."
- If only one exists: partial completion
  - Display: "Audit partially complete. Check .banneker/ for available reports."
- If neither exists: failure
  - Display: "Audit failed. Check for errors above."
  </action>
  <verify>
1. File exists at templates/commands/banneker-audit.md
2. File starts with valid YAML frontmatter (name: banneker-audit)
3. File contains Steps 0-3 matching the lifecycle pattern
4. Step 0 checks for plan files (not survey.json)
5. Step 1 handles existing report detection
6. Step 2 spawns banneker-auditor agent with plan file list and rubric path
7. Step 3 reads and displays grade from JSON report
  </verify>
  <done>
templates/commands/banneker-audit.md exists with valid frontmatter, follows established command lifecycle pattern, discovers plan files automatically, spawns auditor agent with file list and rubric config reference, and displays audit grade on completion.
  </done>
</task>

</tasks>

<verification>
- Both command files have valid YAML frontmatter with correct name fields
- Both follow the Step 0-3 lifecycle pattern from established commands
- banneker-document.md does NOT require survey.json (brownfield-first)
- banneker-audit.md discovers plan files from multiple sources
- Both handle resume/overwrite conditions
- Both spawn their respective sub-agents via Task tool
- Both verify completion with specific success/failure messaging
</verification>

<success_criteria>
- `/banneker:document` command file works on raw codebases without prior Banneker state
- `/banneker:audit` command file discovers plan files from .planning/ or other locations
- Both commands follow the established lifecycle pattern (prerequisite, resume, spawn, verify)
- Both commands provide clear user messaging at each step
</success_criteria>

<output>
After completion, create `.planning/phases/08-brownfield-analysis-audit/08-03-SUMMARY.md`
</output>
