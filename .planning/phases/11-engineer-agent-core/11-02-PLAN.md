---
phase: 11-engineer-agent-core
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - templates/commands/banneker-engineer.md
autonomous: true

must_haves:
  truths:
    - "/banneker:engineer command runs and checks for survey.json"
    - "Command offers resume when state file exists"
    - "Command spawns engineer sub-agent via Task tool"
    - "Command verifies output documents exist after completion"
  artifacts:
    - path: "templates/commands/banneker-engineer.md"
      provides: "Orchestrator skill file for /banneker:engineer"
      min_lines: 150
      contains: "banneker-engineer"
  key_links:
    - from: "templates/commands/banneker-engineer.md"
      to: "templates/agents/banneker-engineer.md"
      via: "spawns sub-agent via Task tool"
      pattern: "Task.*banneker-engineer"
    - from: "templates/commands/banneker-engineer.md"
      to: ".banneker/survey.json"
      via: "prerequisite check"
      pattern: "survey\\.json"
---

<objective>
Create the engineer command orchestrator skill file that handles prerequisites, resume detection, sub-agent spawning, and output verification for the /banneker:engineer command.

Purpose: Provide the user-facing entry point that manages the engineer lifecycle, following the banneker-architect.md orchestrator pattern.

Output: Command skill file that can be installed to enable /banneker:engineer.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-engineer-agent-core/11-RESEARCH.md

# Pattern reference (follow this structure exactly)
@templates/commands/banneker-architect.md

# Sub-agent created in Plan 01
@templates/agents/banneker-engineer.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create banneker-engineer.md orchestrator</name>
  <files>templates/commands/banneker-engineer.md</files>
  <action>
Create the engineer command orchestrator following the banneker-architect.md orchestrator pattern exactly. Structure:

**Frontmatter:**
```yaml
---
name: banneker-engineer
description: "Synthesize survey data into engineering documents with explicit confidence levels. Generates DIAGNOSIS.md (what is known/unknown), RECOMMENDATION.md (options analysis), and ENGINEERING-PROPOSAL.md (DEC-XXX decisions for approval)."
---
```

**# banneker-engineer**

Opening paragraph explaining role: "You are the engineer command orchestrator. Your job is to manage the engineering document generation lifecycle: check prerequisites, detect resume conditions, spawn the engineer sub-agent to synthesize documents, and verify outputs on completion."

**## Step 0: Prerequisite Check (MANDATORY)**

Check that survey data exists:

### Check for survey.json
Read `.banneker/survey.json`:
```bash
cat .banneker/survey.json 2>/dev/null
```

If NOT exists:
- Display: "No survey data found at .banneker/survey.json"
- Display: "Run /banneker:survey first to conduct a discovery interview."
- Display: "Note: /banneker:engineer works with partial survey data if you've completed at least Phases 1-3 (pitch, actors, walkthroughs)."
- Abort and exit

### Check survey minimum viability
Parse survey.json and check:
- `project` object exists
- `actors` array exists and has length > 0
- `walkthroughs` array exists and has length > 0

If any missing:
- Display: "Survey data incomplete. Minimum required: project details, actors, and at least one walkthrough."
- Display: "Continue /banneker:survey to complete Phases 1-3 before running engineer."
- Abort and exit

**## Step 1: Resume Detection (REQ-CONT-002 / ENGINT-05)**

### Check for interrupted generation
Read `.banneker/state/engineer-state.md` if it exists:
```bash
cat .banneker/state/engineer-state.md 2>/dev/null
```

If file exists:
1. Parse state to identify completed/pending documents
2. Display: "Found interrupted engineering session. Completed: [list]. Remaining: [list]."
3. Prompt: "Resume generation? (y/N)"
   - Yes: Proceed to Step 2 with resume context
   - No: Prompt: "Start fresh? This will regenerate all documents. (y/N)"
     - Yes: Delete state file, proceed as fresh start
     - No: Abort

### Check for existing documents
```bash
ls .banneker/documents/DIAGNOSIS.md .banneker/documents/RECOMMENDATION.md .banneker/documents/ENGINEERING-PROPOSAL.md 2>/dev/null
```

If documents exist AND no state file:
1. Display: "Existing engineering documents found."
2. List documents with sizes
3. Prompt: "Overwrite with fresh generation? (y/N)"
   - Yes: Proceed as fresh start
   - No: Abort

If neither state file nor documents exist: Proceed as fresh start.

**## Step 2: Ensure Directory Structure**

```bash
mkdir -p .banneker/documents
mkdir -p .banneker/state
```

**## Step 3: Spawn Engineer Sub-Agent**

Use Task tool to spawn `banneker-engineer` sub-agent:

- **Task name**: "Synthesize engineering documents from survey data"
- **Agent reference**: `banneker-engineer`
- **Context to pass**:
  - If resuming: Pass state file content with instruction: "Resume from current state. Skip completed documents."
  - If fresh start: Pass: "Fresh start - no prior state. Begin with Step 1: Load and Parse Inputs."

The engineer agent will:
- Load survey.json (handles partial data)
- Analyze survey completeness and establish confidence baseline
- Generate DIAGNOSIS.md, RECOMMENDATION.md, ENGINEERING-PROPOSAL.md sequentially
- Apply confidence markers with rationale
- Write state updates after each document
- Delete state file on success

Wait for engineer to return.

**## Step 4: Verify Completion**

### Verify documents generated
```bash
cat .banneker/documents/DIAGNOSIS.md 2>/dev/null
cat .banneker/documents/RECOMMENDATION.md 2>/dev/null
cat .banneker/documents/ENGINEERING-PROPOSAL.md 2>/dev/null
```

Check each file exists and is non-empty (>100 bytes).

### Display Results

**On success:**
```
Engineering document generation complete!

Generated documents:
  - .banneker/documents/DIAGNOSIS.md (X KB)
  - .banneker/documents/RECOMMENDATION.md (Y KB)
  - .banneker/documents/ENGINEERING-PROPOSAL.md (Z KB)

IMPORTANT: Proposals in ENGINEERING-PROPOSAL.md are NOT yet approved.

Next steps:
  - Review DIAGNOSIS.md to understand survey coverage and gaps
  - Review RECOMMENDATION.md to understand options analysis
  - Review ENGINEERING-PROPOSAL.md for proposed decisions
  - Run /banneker:approve-proposal to review and approve individual decisions (Phase 13)
```

**On failure:**
```
Engineering document generation incomplete

Missing documents:
  - [list missing files]

State file preserved at .banneker/state/engineer-state.md

To retry: Run /banneker:engineer again to resume
```

**## Important Implementation Notes**

- This skill file runs inside AI runtime (Claude Code, OpenCode, Gemini)
- All file operations via runtime's Bash tool
- Orchestrator is lean - document synthesis logic lives in engineer sub-agent
- Resume detection (Step 1) is MANDATORY per REQ-CONT-002 and ENGINT-05
- State file is engineer's responsibility to write/update/delete
- CRITICAL: Do NOT merge proposals to architecture-decisions.json - requires user approval

**## Requirements Coverage**

- **ENGINT-01**: Standalone /banneker:engineer command (this file)
- **ENGINT-02**: Partial survey support (minimum viability check, engineer handles rest)
- **ENGINT-05**: State tracking via `.banneker/state/engineer-state.md`
- **REQ-CONT-002**: Resume detection in Step 1
  </action>
  <verify>
File exists at templates/commands/banneker-engineer.md with:
- grep "banneker-engineer" returns results
- grep "survey.json" returns results
- grep "engineer-state.md" returns results
- grep "DIAGNOSIS.md" returns results
- grep "RECOMMENDATION.md" returns results
- grep "ENGINEERING-PROPOSAL.md" returns results
- grep -i "resume" returns results
- grep "Task" returns results (spawns sub-agent)
- File is >150 lines
  </verify>
  <done>
Engineer command orchestrator handles prerequisites, resume, sub-agent spawning, and output verification. ENGINT-01 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add engineer to existing commands list reference</name>
  <files>templates/commands/banneker-engineer.md</files>
  <action>
Verify the command file includes a "Related Commands" or "Next Steps" section that references:
- /banneker:survey (prerequisite)
- /banneker:architect (alternative/complementary)
- /banneker:approve-proposal (next step - Phase 13, can note "coming in v0.3.0")

If the file from Task 1 doesn't have this, add a section at the end:

```markdown
## Related Commands

- `/banneker:survey` - Run discovery interview to create survey.json (prerequisite)
- `/banneker:architect` - Generate planning documents from survey (alternative path)
- `/banneker:approve-proposal` - Review and approve proposed decisions (Phase 13)
```

This helps users understand the workflow.
  </action>
  <verify>
grep "Related Commands\|Next steps\|banneker:survey" templates/commands/banneker-engineer.md returns results
  </verify>
  <done>
Command file references related commands for user workflow clarity.
  </done>
</task>

</tasks>

<verification>
1. templates/commands/banneker-engineer.md exists
2. File follows banneker-architect.md orchestrator pattern
3. Prerequisite check for survey.json with minimum viability
4. Resume detection with user prompts
5. Sub-agent spawning via Task tool
6. Output verification for all three documents
7. Clear next steps mentioning approval requirement
</verification>

<success_criteria>
- templates/commands/banneker-engineer.md exists with complete orchestrator logic
- Follows banneker-architect.md pattern exactly
- ENGINT-01 (standalone command) satisfied
- ENGINT-02 (partial survey) addressed via minimum viability check
- ENGINT-05 (state tracking) integrated with resume detection
</success_criteria>

<output>
After completion, create `.planning/phases/11-engineer-agent-core/11-02-SUMMARY.md`
</output>
