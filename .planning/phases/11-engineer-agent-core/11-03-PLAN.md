---
phase: 11-engineer-agent-core
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - templates/agents/banneker-engineer.md
autonomous: true

must_haves:
  truths:
    - "Engineer detects partial survey data and adjusts confidence accordingly"
    - "Engineer writes state file after each document completion"
    - "Engineer can resume from state file, skipping completed documents"
    - "Gaps in survey data are explicitly noted in DIAGNOSIS.md"
  artifacts:
    - path: "templates/agents/banneker-engineer.md"
      provides: "Enhanced engineer with state management and partial data handling"
      contains: "engineer-state.md"
  key_links:
    - from: "templates/agents/banneker-engineer.md"
      to: ".banneker/state/engineer-state.md"
      via: "writes/reads state for resume"
      pattern: "engineer-state\\.md"
    - from: "templates/agents/banneker-engineer.md"
      to: ".banneker/survey.json"
      via: "detects partial data via schema validation"
      pattern: "rubric_coverage|backend\\.applicable"
---

<objective>
Enhance the engineer sub-agent with robust state management for resume-on-interrupt capability and partial survey data detection with graceful degradation.

Purpose: Ensure the engineer can handle mid-interview cliff scenarios where survey.json is incomplete, producing valid output with appropriately reduced confidence. Enable resume if generation is interrupted.

Output: Enhanced banneker-engineer.md with complete state management and partial data handling.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-engineer-agent-core/11-RESEARCH.md

# Sub-agent to enhance (created in Plan 01)
@templates/agents/banneker-engineer.md

# State management pattern reference
@templates/agents/banneker-architect.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance partial survey data detection</name>
  <files>templates/agents/banneker-engineer.md</files>
  <action>
Enhance the engineer sub-agent's "Step 2: Analyze Survey Completeness" section with detailed partial data detection. Add or expand:

**Survey Completeness Analysis Section:**

```markdown
## Step 2: Analyze Survey Completeness (ENGINT-02)

Detect gaps in survey.json to calibrate confidence levels and generate explicit gap documentation.

### Minimum Viable Survey Check

The minimum viable survey for engineer operation requires:
- `survey.project` object (Phase 1 pitch)
- `survey.actors` array with length > 0 (Phase 2)
- `survey.walkthroughs` array with length > 0 (Phase 3)

If minimum not met, abort with message explaining which phases are missing.

### Section Completeness Detection

Check each survey section and flag gaps:

**Phase 1 - Project Details:**
- project.name: REQUIRED
- project.one_liner: REQUIRED
- project.problem_statement: Helpful but optional

**Phase 2 - Actors:**
- actors[].name: REQUIRED for each
- actors[].type: Helpful for filtering
- actors[].role: Helpful for context

**Phase 3 - Walkthroughs:**
- walkthroughs[].actor: REQUIRED
- walkthroughs[].steps: REQUIRED, length > 0
- walkthroughs[].data_changes: Helpful for data model
- walkthroughs[].error_cases: Helpful for robustness

**Phase 4 - Backend (if applicable):**
```javascript
const backendGaps = [];
if (survey.backend) {
    if (survey.backend.applicable === true) {
        // Backend is applicable, check completeness
        if (!survey.backend.data_stores || survey.backend.data_stores.length === 0) {
            backendGaps.push('backend.data_stores: No data stores defined');
        }
        if (!survey.backend.integrations) {
            backendGaps.push('backend.integrations: External integrations not captured');
        }
        if (!survey.backend.hosting || !survey.backend.hosting.platform) {
            backendGaps.push('backend.hosting: Deployment platform not specified');
        }
        if (!survey.backend.stack || survey.backend.stack.length === 0) {
            backendGaps.push('backend.stack: Technology stack not defined');
        }
    }
    // backend.applicable === false is valid (frontend-only project)
} else {
    // No backend section at all - major gap
    backendGaps.push('backend: Entire backend section missing - was Phase 4 skipped?');
}
```

**Phase 5 - Gaps & Rubric:**
```javascript
const rubricGaps = [];
if (survey.rubric_coverage) {
    if (survey.rubric_coverage.gaps && survey.rubric_coverage.gaps.length > 0) {
        // User already identified gaps during survey
        rubricGaps.push(...survey.rubric_coverage.gaps.map(g => `rubric_gap: ${g}`));
    }
} else {
    rubricGaps.push('rubric_coverage: Gap analysis section missing - was Phase 5 completed?');
}
```

### Compute Survey Completeness Percentage

```javascript
function computeCompleteness(survey) {
    const sections = {
        project: survey.project ? 1 : 0,
        actors: survey.actors && survey.actors.length > 0 ? 1 : 0,
        walkthroughs: survey.walkthroughs && survey.walkthroughs.length > 0 ? 1 : 0,
        backend: survey.backend ? (survey.backend.applicable === false ? 1 :
            (survey.backend.data_stores?.length > 0 ? 1 : 0.5)) : 0,
        rubric: survey.rubric_coverage ? 1 : 0,
        decisions: survey.architecture_decisions ? 1 : 0
    };

    const total = Object.values(sections).reduce((a, b) => a + b, 0);
    return Math.round((total / 6) * 100);
}
```

### Establish Confidence Baseline

Based on survey completeness:
- 80-100% complete: Confidence baseline HIGH (can assign HIGH to well-supported recommendations)
- 50-79% complete: Confidence baseline MEDIUM (cap most recommendations at MEDIUM)
- <50% complete: Confidence baseline LOW (all recommendations get LOW unless very well supported)

Store this baseline for use during document generation.
```

**CRITICAL - Partial Data Behavior:**
- Generate ALL three documents even with partial data
- Explicitly state gaps in DIAGNOSIS.md "What Is Missing" section
- Downgrade confidence for recommendations touching gap areas
- Never invent data not in survey - state the gap instead
- Example: "Survey gap: No database specified. Cannot recommend specific database. Assuming relational storage needed based on entity relationships in walkthroughs."
  </action>
  <verify>
grep "Analyze Survey Completeness\|ENGINT-02\|computeCompleteness\|Confidence baseline" templates/agents/banneker-engineer.md returns results
  </verify>
  <done>
Engineer can detect partial survey data, compute completeness percentage, establish confidence baseline, and handle gaps gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement state management for resume</name>
  <files>templates/agents/banneker-engineer.md</files>
  <action>
Add comprehensive state management to the engineer sub-agent for ENGINT-05. Add or expand:

**State File Section:**

```markdown
## State Management (ENGINT-05)

Write state to `.banneker/state/engineer-state.md` after each document completes. This enables resume if generation is interrupted.

### State File Structure

```markdown
---
command: engineer
status: in-progress
started_at: 2026-02-03T10:00:00Z
last_updated: 2026-02-03T10:15:00Z
items_completed: 1
items_total: 3
current_position: "RECOMMENDATION.md generation"
---

## Survey Analysis

**Survey completeness:** 65%
**Confidence baseline:** MEDIUM

**Identified gaps:**
- backend.infrastructure: Hosting details not captured
- rubric_coverage.gaps: ["testing-strategy", "deployment-process"]

## Progress

- [x] DIAGNOSIS.md (completed 2026-02-03T10:05:00Z, 2847 bytes)
- [ ] RECOMMENDATION.md (in progress)
- [ ] ENGINEERING-PROPOSAL.md (pending)

## Generated Documents

### DIAGNOSIS.md
- Path: .banneker/documents/DIAGNOSIS.md
- Completed: 2026-02-03T10:05:00Z
- Size: 2847 bytes
- Gap count: 5

## Next Steps

1. Generate RECOMMENDATION.md addressing identified gaps
2. Mark recommendations touching gap areas as MEDIUM or LOW confidence
3. Generate ENGINEERING-PROPOSAL.md with ADR format decisions
```

### Write State After Each Document

After completing each document:

```javascript
function updateState(documentType, documentPath, documentSize) {
    const state = readStateFile() || initializeState();

    // Mark document complete
    state.completed.push({
        document: documentType,
        path: documentPath,
        timestamp: new Date().toISOString(),
        size: documentSize
    });

    // Update progress
    state.items_completed = state.completed.length;
    state.last_updated = new Date().toISOString();

    // Determine next step
    const pending = ['DIAGNOSIS.md', 'RECOMMENDATION.md', 'ENGINEERING-PROPOSAL.md']
        .filter(d => !state.completed.some(c => c.document === d));
    state.current_position = pending.length > 0 ?
        `${pending[0]} generation` : 'Complete';

    writeStateFile(state);
}
```

### Resume From State

When spawned with resume context:

1. Parse state file to identify:
   - Which documents are complete (skip regenerating)
   - Survey analysis (don't re-analyze)
   - Where to resume (current_position)

2. Load already-generated documents:
   - Read DIAGNOSIS.md if complete (needed for RECOMMENDATION input)
   - Read RECOMMENDATION.md if complete (needed for PROPOSAL input)

3. Continue from current_position:
   - If RECOMMENDATION.md pending: Generate it using DIAGNOSIS
   - If ENGINEERING-PROPOSAL.md pending: Generate it using RECOMMENDATION

4. Maintain consistency:
   - Use same confidence baseline from state
   - Use same gap analysis from state
   - Don't change already-written documents

### Delete State on Completion

After all three documents are successfully generated:

```javascript
function onCompletion() {
    // Delete state file
    deleteFile('.banneker/state/engineer-state.md');

    // Report results
    reportResults();
}
```

### Preserve State on Failure

If any document generation fails:
- Do NOT delete state file
- Write current progress to state
- Allow resume on retry
```

**Add state writing calls to each document generation step:**

After Step 3 (DIAGNOSIS.md):
```markdown
Write DIAGNOSIS.md to .banneker/documents/DIAGNOSIS.md
Update state: mark DIAGNOSIS.md complete with timestamp and size
```

After Step 4 (RECOMMENDATION.md):
```markdown
Write RECOMMENDATION.md to .banneker/documents/RECOMMENDATION.md
Update state: mark RECOMMENDATION.md complete with timestamp and size
```

After Step 5 (ENGINEERING-PROPOSAL.md):
```markdown
Write ENGINEERING-PROPOSAL.md to .banneker/documents/ENGINEERING-PROPOSAL.md
Delete state file (generation complete)
```
  </action>
  <verify>
grep "State Management\|engineer-state.md\|updateState\|Resume From State" templates/agents/banneker-engineer.md returns results
  </verify>
  <done>
Engineer writes state after each document, can resume from state file skipping completed documents, and cleans up state on success. ENGINT-05 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add resume handling section</name>
  <files>templates/agents/banneker-engineer.md</files>
  <action>
Add a dedicated "Resume Handling" section (similar to banneker-architect.md) that explains the resume protocol clearly:

```markdown
## Resume Handling

If you are spawned and receive resume context indicating an existing `.banneker/state/engineer-state.md`, this is a continuation after interruption.

**Resume Protocol:**

1. **Parse state file:**
   - Extract completed documents list
   - Extract survey analysis (completeness, gaps, confidence baseline)
   - Identify current_position

2. **Load dependencies:**
   - If resuming at RECOMMENDATION.md: Read existing DIAGNOSIS.md
   - If resuming at ENGINEERING-PROPOSAL.md: Read existing DIAGNOSIS.md and RECOMMENDATION.md

3. **Show resume status:**
   ```
   Resuming engineer session from 2026-02-03T10:00:00Z

   Already completed:
     [x] DIAGNOSIS.md (2847 bytes)

   Remaining:
     [ ] RECOMMENDATION.md
     [ ] ENGINEERING-PROPOSAL.md

   Continuing from RECOMMENDATION.md...
   ```

4. **Continue generation:**
   - Use existing survey analysis (don't re-analyze)
   - Use existing confidence baseline
   - Generate remaining documents in order

5. **Maintain consistency:**
   - References to DIAGNOSIS in RECOMMENDATION must match actual DIAGNOSIS content
   - References to RECOMMENDATION in PROPOSAL must match actual RECOMMENDATION content

6. **Complete normally:**
   - Delete state file on success
   - Report results as normal
```
  </action>
  <verify>
grep "Resume Handling\|Resume Protocol" templates/agents/banneker-engineer.md returns results
  </verify>
  <done>
Resume handling documented with clear protocol for continuing interrupted sessions.
  </done>
</task>

</tasks>

<verification>
1. Partial survey detection logic complete with section-by-section analysis
2. Survey completeness percentage computation included
3. Confidence baseline establishment based on completeness
4. State file structure defined with all required fields
5. State written after each document completion
6. Resume protocol documented and implemented
7. State deleted on successful completion
</verification>

<success_criteria>
- Engineer detects partial survey data and adjusts confidence baseline
- State file written after each document with progress tracking
- Resume continues from where interrupted, skipping completed documents
- ENGINT-02 (partial data) and ENGINT-05 (state tracking) fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/11-engineer-agent-core/11-03-SUMMARY.md`
</output>
