---
phase: 13-approval-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/approval.js
  - lib/approval-display.js
autonomous: true

must_haves:
  truths:
    - "Approved decisions merge to architecture-decisions.json"
    - "Rejected decisions are logged with reason to rejection-log.json"
    - "Merge operation is atomic (backup + tmp file + rename)"
    - "Summary table displays decisions grouped by category"
  artifacts:
    - path: "lib/approval.js"
      provides: "Atomic merge logic for decisions"
      exports: ["mergeApprovedDecisions", "logRejectedDecisions"]
    - path: "lib/approval-display.js"
      provides: "Table formatting and display functions"
      exports: ["displayProposalsSummary", "formatConfidence"]
  key_links:
    - from: "lib/approval.js"
      to: ".banneker/architecture-decisions.json"
      via: "atomic file write with backup"
      pattern: "fs\\.rename.*\\.tmp"
    - from: "lib/approval.js"
      to: ".banneker/rejection-log.json"
      via: "append rejection entries"
      pattern: "log\\.rejections\\.push"
---

<objective>
Create the core approval library modules that handle decision merging and display.

Purpose: Provide the foundation for the approval workflow - atomic JSON merging with backup/restore, rejection logging for audit trails, and category-grouped table display for efficient decision review.

Output: Two lib modules (approval.js, approval-display.js) with zero external dependencies following established Banneker patterns.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-approval-flow/13-RESEARCH.md

# Existing patterns to follow
@lib/prompts.js
@lib/installer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create approval.js with atomic merge and rejection logging</name>
  <files>lib/approval.js</files>
  <action>
Create lib/approval.js with the following exports:

1. `mergeApprovedDecisions(approvedDecisions)` - Atomic merge to architecture-decisions.json
   - Read existing .banneker/architecture-decisions.json (or initialize empty structure)
   - Create backup before modification (.backup suffix)
   - Append approved decisions to decisions array
   - Update recorded_at timestamp
   - Write to .tmp file first, then rename (atomic POSIX operation)
   - Remove backup on success
   - Return count of merged decisions

2. `logRejectedDecisions(rejectedDecisions, reasons)` - Append to rejection-log.json
   - Read existing .banneker/rejection-log.json (or initialize { rejections: [] })
   - Append each rejection with:
     - timestamp (ISO string)
     - decision_id
     - question
     - proposed_choice
     - reason (from reasons array or "User rejected without reason")
     - full_decision (complete object for recovery)
     - status: "rejected"
   - Write updated log

Use Node.js built-ins only (node:fs/promises, node:path). Follow patterns from lib/installer.js for file operations.

Do NOT use synchronous fs operations for the JSON read/write - use fs/promises for async consistency with other Banneker lib modules.
  </action>
  <verify>
Create a simple test script that:
1. Calls mergeApprovedDecisions with a test decision
2. Verifies architecture-decisions.json contains the decision
3. Calls logRejectedDecisions with a test rejection
4. Verifies rejection-log.json contains the rejection
Run: `node -e "import('./lib/approval.js').then(m => console.log(Object.keys(m)))"`
  </verify>
  <done>
- mergeApprovedDecisions function exists and performs atomic write
- logRejectedDecisions function exists and appends to rejection log
- Both functions use async fs/promises APIs
- Both handle missing files gracefully (initialize empty structures)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create approval-display.js with table formatting</name>
  <files>lib/approval-display.js</files>
  <action>
Create lib/approval-display.js with the following exports:

1. `displayProposalsSummary(proposals)` - Category-grouped table display
   - Group proposals by domain field (e.g., "RUB-INFRA", "RUB-INT")
   - Display header: "Proposed Decisions" with count
   - For each domain group:
     - Display domain name with decision count
     - Display separator line
     - For each decision: numbered marker, ID, question, choice, confidence
   - Use ANSI color codes from installer.js pattern (brightPurple, cyan, yellow, white, gray)
   - Detect terminal width (process.stdout.columns || 80) and truncate if needed

2. `formatConfidence(confidence)` - Format confidence level with color
   - HIGH: brightPurple
   - MEDIUM: yellow
   - LOW: gray
   - Not specified: gray with "(not specified)" text

3. `truncateText(text, maxLen)` - Truncate text with ellipsis
   - If text.length <= maxLen, return text
   - Otherwise return text.slice(0, maxLen - 3) + '...'

Import colors object definition from installer.js or duplicate the ANSI codes (they're simple constants). Do NOT add any dependencies.

Terminal width detection: Use `process.stdout.columns || 80` for default width.
  </action>
  <verify>
Create a test script that:
1. Imports approval-display.js
2. Calls displayProposalsSummary with sample proposals
3. Visually verify table output is formatted correctly
Run: `node -e "import('./lib/approval-display.js').then(m => m.displayProposalsSummary([{id:'DEC-001',domain:'INFRA',question:'Test?',choice:'Yes',confidence:'HIGH'}]))"`
  </verify>
  <done>
- displayProposalsSummary function exists and groups by domain
- formatConfidence function exists with color coding
- truncateText function exists for long text handling
- Output uses ANSI colors and respects terminal width
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `ls lib/approval*.js` shows both files
2. Both modules export their functions correctly (test with dynamic import)
3. No external dependencies added (check package.json unchanged)
4. Atomic write pattern uses .tmp + rename (grep for pattern)
</verification>

<success_criteria>
- [ ] lib/approval.js exports mergeApprovedDecisions and logRejectedDecisions
- [ ] lib/approval-display.js exports displayProposalsSummary and formatConfidence
- [ ] Merge uses atomic write pattern (backup, .tmp, rename)
- [ ] Rejection log includes full_decision for recovery
- [ ] Display groups by domain with color-coded confidence
- [ ] Zero external dependencies (Node.js built-ins only)
</success_criteria>

<output>
After completion, create `.planning/phases/13-approval-flow/13-01-SUMMARY.md`
</output>
