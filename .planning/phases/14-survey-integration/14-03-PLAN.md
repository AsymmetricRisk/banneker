---
phase: 14-survey-integration
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - test/integration/surveyor-integration.test.js
  - test/integration/installer.test.js
autonomous: true

must_haves:
  truths:
    - "Integration tests verify cliff detection -> offer -> handoff flow"
    - "Tests verify decline flow preserves survey continuation"
    - "Schema extension tests pass"
    - "Installer tests verify surveyor agent installs correctly"
  artifacts:
    - path: "test/integration/surveyor-integration.test.js"
      provides: "Integration tests for survey-to-engineer flow"
      min_lines: 100
    - path: "test/integration/installer.test.js"
      provides: "Extended installer tests for surveyor agent"
      contains: "banneker-surveyor"
  key_links:
    - from: "test/integration/surveyor-integration.test.js"
      to: "lib/cliff-detection.js"
      via: "imports detectExplicitCliff"
      pattern: "detectExplicitCliff"
    - from: "test/integration/surveyor-integration.test.js"
      to: "schemas/survey.schema.json"
      via: "validates survey with surveyor_notes"
      pattern: "surveyor_notes"
---

<objective>
Create integration tests for the complete survey-to-engineer flow and verify installer handles updated surveyor agent.

Purpose: Ensure mid-survey takeover works end-to-end and schema changes don't break existing functionality.
Output: Comprehensive integration tests for Phase 14 features
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-survey-integration/14-RESEARCH.md

# Prior plans establish surveyor modifications
@.planning/phases/14-survey-integration/14-01-PLAN.md
@.planning/phases/14-survey-integration/14-02-PLAN.md

# Existing test patterns
@test/integration/installer.test.js
@test/unit/cliff-detection.test.js
@lib/cliff-detection.js
@schemas/survey.schema.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create surveyor integration tests</name>
  <files>test/integration/surveyor-integration.test.js</files>
  <action>
Create a new test file for surveyor integration tests. Follow existing test patterns from the codebase (Jest, describe/it blocks, assert/strict).

```javascript
import { describe, it, beforeEach, afterEach } from 'node:test';
import assert from 'node:assert/strict';
import { readFile, writeFile, mkdir, rm } from 'node:fs/promises';
import { join } from 'node:path';
import { detectExplicitCliff, EXPLICIT_CLIFF_SIGNALS } from '../../lib/cliff-detection.js';

describe('Surveyor Integration', () => {
  let tempDir;

  beforeEach(async () => {
    tempDir = join(process.cwd(), 'test-temp-surveyor-' + Date.now());
    await mkdir(tempDir, { recursive: true });
    await mkdir(join(tempDir, '.banneker', 'state'), { recursive: true });
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  describe('Cliff Detection in Survey Context', () => {
    it('should detect cliff signal in survey response', () => {
      const response = "I don't know how to set up the database";
      const result = detectExplicitCliff(response);

      assert.equal(result.detected, true);
      assert.equal(result.confidence, 'HIGH');
      assert.equal(result.signal, "i don't know");
    });

    it('should not trigger on simple confirmations', () => {
      const confirmations = ['yes', 'looks good', 'correct', 'that\'s right'];

      for (const response of confirmations) {
        const result = detectExplicitCliff(response);
        assert.equal(result.detected, false, `Should not detect in: "${response}"`);
      }
    });

    it('should detect multiple signals in conversation', () => {
      const responses = [
        "The project is a task manager",  // No signal
        "Users can create tasks",          // No signal
        "I don't know what database to use",  // Signal
        "Maybe PostgreSQL?",               // No signal
        "Whatever you think is best for caching"  // Signal
      ];

      const detected = responses.filter(r => detectExplicitCliff(r).detected);
      assert.equal(detected.length, 2);
    });
  });

  describe('Cliff State Tracking', () => {
    it('should build cliff signals array', () => {
      const cliffSignals = [];
      const responses = [
        { phase: 'pitch', question: 'What is your project?', response: 'A task manager' },
        { phase: 'backend', question: 'What database?', response: "I don't know" },
        { phase: 'backend', question: 'Caching strategy?', response: 'Whatever you think' }
      ];

      for (const r of responses) {
        const detection = detectExplicitCliff(r.response);
        if (detection.detected) {
          cliffSignals.push({
            timestamp: new Date().toISOString(),
            phase: r.phase,
            question_context: r.question,
            user_response: r.response,
            detected_signal: detection.signal,
            confidence: detection.confidence,
            mode_switch_offered: false,
            user_accepted: null
          });
        }
      }

      assert.equal(cliffSignals.length, 2);
      assert.equal(cliffSignals[0].phase, 'backend');
      assert.equal(cliffSignals[1].detected_signal, 'whatever you think');
    });

    it('should track declined offers count', () => {
      let declinedOffers = 0;
      const SUPPRESSION_THRESHOLD = 2;

      // Simulate two declines
      declinedOffers++;
      assert.equal(declinedOffers < SUPPRESSION_THRESHOLD, true);

      declinedOffers++;
      assert.equal(declinedOffers >= SUPPRESSION_THRESHOLD, true);

      // Should suppress offers after threshold
      const shouldOffer = declinedOffers < SUPPRESSION_THRESHOLD;
      assert.equal(shouldOffer, false);
    });
  });

  describe('Context Handoff Generation', () => {
    it('should generate surveyor_notes structure', () => {
      const surveyorNotes = {
        generated: new Date().toISOString(),
        phase_at_switch: 'backend',
        cliff_trigger: "I don't know what database to use",
        survey_completeness_percent: 55,
        preferences_observed: ['Prefers managed services', 'Budget-conscious'],
        implicit_constraints: ['Solo developer', 'First production app'],
        confident_topics: ['Problem domain', 'User flows'],
        uncertain_topics: ['Database selection', 'Infrastructure'],
        deferred_questions: [
          { phase: 'backend', question: 'What caching strategy?', deferred_at: new Date().toISOString() }
        ],
        engineer_guidance: ['Start with simple approach', 'Include cost considerations']
      };

      // Verify required fields
      assert.ok(surveyorNotes.generated);
      assert.ok(surveyorNotes.phase_at_switch);

      // Verify arrays are populated
      assert.ok(surveyorNotes.preferences_observed.length > 0);
      assert.ok(surveyorNotes.implicit_constraints.length > 0);
    });

    it('should generate surveyor-context.md content', () => {
      const surveyorNotes = {
        generated: '2026-02-03T10:30:00Z',
        phase_at_switch: 'backend',
        cliff_trigger: "I don't know",
        survey_completeness_percent: 55,
        preferences_observed: ['Prefers managed services'],
        implicit_constraints: ['Solo developer'],
        confident_topics: ['User flows'],
        uncertain_topics: ['Infrastructure'],
        deferred_questions: [],
        engineer_guidance: ['Start simple']
      };

      const contextContent = `---
generated: ${surveyorNotes.generated}
phase_at_switch: ${surveyorNotes.phase_at_switch}
cliff_trigger: "${surveyorNotes.cliff_trigger}"
survey_completeness: ${surveyorNotes.survey_completeness_percent}%
---

## User Preferences Observed

During conversation, user indicated:
${surveyorNotes.preferences_observed.map(p => `- ${p}`).join('\n')}

## Implicit Constraints

${surveyorNotes.implicit_constraints.map(c => `- ${c}`).join('\n')}

## Topics User Felt Confident About

${surveyorNotes.confident_topics.map(t => `- ${t}`).join('\n')}

## Topics User Felt Uncertain About

${surveyorNotes.uncertain_topics.map(t => `- ${t}`).join('\n')}

## Recommendations for Engineer Agent

${surveyorNotes.engineer_guidance.map(g => `- ${g}`).join('\n')}
`;

      assert.ok(contextContent.includes('phase_at_switch: backend'));
      assert.ok(contextContent.includes('Prefers managed services'));
      assert.ok(contextContent.includes('Solo developer'));
    });
  });

  describe('Partial Survey JSON Generation', () => {
    it('should generate partial survey with status marker', async () => {
      const partialSurvey = {
        survey_metadata: {
          version: '1.0',
          created: '2026-02-03T10:00:00Z',
          runtime: 'claude-code',
          status: 'partial'
        },
        project: {
          name: 'TaskFlow',
          one_liner: 'A task management app',
          problem_statement: 'Teams need better task tracking'
        },
        actors: [
          { name: 'User', type: 'human', role: 'End user', capabilities: ['create tasks'] }
        ],
        walkthroughs: [
          {
            name: 'Create Task',
            type: 'primary',
            steps: ['Open app', 'Click new', 'Enter details'],
            system_responses: ['Show form', 'Save task'],
            data_changes: ['Task created'],
            error_cases: ['Invalid input']
          }
        ],
        backend: { applicable: 'unknown' },
        rubric_coverage: { covered: ['actors', 'walkthroughs'], gaps: ['backend'] },
        cliff_signals: [],
        surveyor_notes: {
          generated: '2026-02-03T10:30:00Z',
          phase_at_switch: 'backend'
        }
      };

      // Write to temp file
      const surveyPath = join(tempDir, '.banneker', 'survey.json');
      await writeFile(surveyPath, JSON.stringify(partialSurvey, null, 2));

      // Read back and verify
      const content = await readFile(surveyPath, 'utf-8');
      const parsed = JSON.parse(content);

      assert.equal(parsed.survey_metadata.status, 'partial');
      assert.ok(parsed.surveyor_notes);
      assert.equal(parsed.surveyor_notes.phase_at_switch, 'backend');
    });

    it('should compute completeness percentage correctly', () => {
      const computeCompleteness = (phases) => {
        const weights = { pitch: 15, actors: 20, walkthroughs: 20, backend: 20, gaps: 15, decisions: 10 };
        let total = 0;
        for (const phase of phases) {
          total += weights[phase] || 0;
        }
        return total;
      };

      assert.equal(computeCompleteness(['pitch']), 15);
      assert.equal(computeCompleteness(['pitch', 'actors']), 35);
      assert.equal(computeCompleteness(['pitch', 'actors', 'walkthroughs']), 55);
      assert.equal(computeCompleteness(['pitch', 'actors', 'walkthroughs', 'backend']), 75);
    });
  });

  describe('Decline Flow', () => {
    it('should preserve survey state on decline', () => {
      const surveyState = {
        currentPhase: 'backend',
        declinedOffers: 0,
        pendingOffer: { detection: { detected: true, signal: "i don't know" } },
        cliffSignals: []
      };

      // Simulate decline (option 2: continue survey)
      surveyState.declinedOffers++;
      surveyState.pendingOffer.cliffEntry = {
        mode_switch_offered: true,
        user_accepted: false
      };
      surveyState.cliffSignals.push(surveyState.pendingOffer.cliffEntry);
      surveyState.pendingOffer = null;

      assert.equal(surveyState.declinedOffers, 1);
      assert.equal(surveyState.pendingOffer, null);
      assert.equal(surveyState.cliffSignals.length, 1);
      assert.equal(surveyState.cliffSignals[0].user_accepted, false);
    });

    it('should add to deferred questions on skip', () => {
      const surveyState = {
        currentPhase: 'backend',
        deferredQuestions: [],
        pendingOffer: {
          detection: { detected: true },
          question: 'What database?'
        }
      };

      // Simulate skip (option 3)
      surveyState.deferredQuestions.push({
        phase: surveyState.currentPhase,
        question: surveyState.pendingOffer.question,
        deferredAt: new Date().toISOString()
      });
      surveyState.pendingOffer = null;

      assert.equal(surveyState.deferredQuestions.length, 1);
      assert.equal(surveyState.deferredQuestions[0].phase, 'backend');
    });
  });
});
```
  </action>
  <verify>Run `npm test -- --test-name-pattern="Surveyor Integration"` and verify:
1. All tests pass
2. Test file has at least 100 lines
3. Tests cover cliff detection, state tracking, context handoff, partial survey, decline flow</verify>
  <done>Integration tests verify complete survey-to-engineer flow</done>
</task>

<task type="auto">
  <name>Task 2: Add installer tests for surveyor agent content</name>
  <files>test/integration/installer.test.js</files>
  <action>
Add tests to the existing installer.test.js to verify the updated surveyor agent installs correctly with cliff detection protocol.

Find the existing agent installation tests (look for "banneker-surveyor" or agent-related tests) and add these new tests to that describe block:

```javascript
it('should install surveyor agent with cliff detection protocol', async () => {
  // Use existing test setup (tempDir/fakeHomeDir pattern)
  const surveyorPath = join(fakeHomeDir, '.claude', 'agents', 'banneker-surveyor.md');
  const content = await readFile(surveyorPath, 'utf-8');

  // Verify cliff detection protocol sections exist
  assert.ok(content.includes('## Cliff Detection Protocol'),
    'Surveyor should have Cliff Detection Protocol section');
  assert.ok(content.includes('## Cliff Tracking State Management'),
    'Surveyor should have Cliff Tracking State Management section');
  assert.ok(content.includes('## Mode Switch Execution Protocol'),
    'Surveyor should have Mode Switch Execution Protocol section');
});

it('should include cliff tracking state fields in surveyor', async () => {
  const surveyorPath = join(fakeHomeDir, '.claude', 'agents', 'banneker-surveyor.md');
  const content = await readFile(surveyorPath, 'utf-8');

  // Verify state fields documented
  assert.ok(content.includes('pendingOffer'),
    'Surveyor should document pendingOffer state field');
  assert.ok(content.includes('declinedOffers'),
    'Surveyor should document declinedOffers state field');
  assert.ok(content.includes('cliffSignals'),
    'Surveyor should document cliffSignals state field');
  assert.ok(content.includes('deferredQuestions'),
    'Surveyor should document deferredQuestions state field');
});

it('should include phase boundary cliff checks in surveyor', async () => {
  const surveyorPath = join(fakeHomeDir, '.claude', 'agents', 'banneker-surveyor.md');
  const content = await readFile(surveyorPath, 'utf-8');

  // Verify cliff detection checks at phase boundaries
  const cliffCheckCount = (content.match(/Cliff detection check:/g) || []).length;
  assert.ok(cliffCheckCount >= 5,
    `Surveyor should have cliff detection checks for phases 1-5, found ${cliffCheckCount}`);
});

it('should include surveyor-context.md documentation', async () => {
  const surveyorPath = join(fakeHomeDir, '.claude', 'agents', 'banneker-surveyor.md');
  const content = await readFile(surveyorPath, 'utf-8');

  // Verify context handoff file documentation
  assert.ok(content.includes('surveyor-context.md'),
    'Surveyor should document surveyor-context.md handoff file');
  assert.ok(content.includes('User Preferences Observed'),
    'Surveyor should document preference extraction in context handoff');
});
```

Place these tests in the appropriate describe block for agent installation tests. Follow the existing test file's structure and naming conventions.
  </action>
  <verify>Run `npm test -- --test-name-pattern="surveyor"` and verify:
1. All new installer tests pass
2. Tests verify cliff detection protocol, state management, phase boundary checks
3. Tests follow existing codebase patterns</verify>
  <done>Installer tests verify surveyor agent installs with Phase 14 features</done>
</task>

<task type="auto">
  <name>Task 3: Add schema validation test for surveyor_notes</name>
  <files>test/integration/installer.test.js</files>
  <action>
Add a test to verify the survey schema includes the surveyor_notes field correctly.

Find the existing schema tests in installer.test.js (or create a new describe block if needed) and add:

```javascript
it('should include surveyor_notes in survey schema', async () => {
  const schemaPath = join(process.cwd(), 'schemas', 'survey.schema.json');
  const content = await readFile(schemaPath, 'utf-8');
  const schema = JSON.parse(content);

  // Verify surveyor_notes property exists
  assert.ok(schema.properties.surveyor_notes,
    'Survey schema should have surveyor_notes property');

  // Verify nested fields
  const notes = schema.properties.surveyor_notes;
  assert.equal(notes.type, 'object');
  assert.ok(notes.properties.generated, 'Should have generated field');
  assert.ok(notes.properties.phase_at_switch, 'Should have phase_at_switch field');
  assert.ok(notes.properties.preferences_observed, 'Should have preferences_observed field');
  assert.ok(notes.properties.implicit_constraints, 'Should have implicit_constraints field');
  assert.ok(notes.properties.engineer_guidance, 'Should have engineer_guidance field');

  // Verify required fields in surveyor_notes
  assert.ok(notes.required.includes('generated'));
  assert.ok(notes.required.includes('phase_at_switch'));

  // Verify surveyor_notes is NOT required at root level
  assert.ok(!schema.required.includes('surveyor_notes'),
    'surveyor_notes should be optional at root level');
});

it('should include status field in survey_metadata', async () => {
  const schemaPath = join(process.cwd(), 'schemas', 'survey.schema.json');
  const content = await readFile(schemaPath, 'utf-8');
  const schema = JSON.parse(content);

  const metadata = schema.properties.survey_metadata;
  assert.ok(metadata.properties.status, 'survey_metadata should have status field');
  assert.deepEqual(metadata.properties.status.enum, ['complete', 'partial'],
    'status should have enum with complete and partial');
});
```
  </action>
  <verify>Run `npm test -- --test-name-pattern="surveyor_notes|survey schema"` and verify:
1. Schema tests pass
2. surveyor_notes structure validated
3. status enum validated</verify>
  <done>Schema tests verify surveyor_notes and status fields</done>
</task>

</tasks>

<verification>
1. `npm test` passes all tests (existing + new)
2. `npm test -- --test-name-pattern="Surveyor"` passes all surveyor integration tests
3. Test count increases by at least 15 tests
4. No test regressions (all prior tests still pass)
</verification>

<success_criteria>
- Integration tests exist for cliff detection -> offer -> handoff flow
- Tests verify decline flow preserves survey continuation
- Schema validation tests pass for surveyor_notes
- Installer tests verify updated surveyor agent
- Full test suite green (`npm test` passes)
</success_criteria>

<output>
After completion, create `.planning/phases/14-survey-integration/14-03-SUMMARY.md`
</output>
