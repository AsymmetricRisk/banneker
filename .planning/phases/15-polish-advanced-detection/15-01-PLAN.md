---
phase: 15-polish-advanced-detection
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/cliff-detection.js
  - test/unit/cliff-detection.test.js
autonomous: true

must_haves:
  truths:
    - "Implicit signals (hedging, quality markers, deferrals) are detected in user responses"
    - "Compound detection requires 2+ implicit signals to trigger"
    - "Explicit signals still trigger immediately with HIGH confidence"
    - "Detection returns structured result with signal category and confidence"
  artifacts:
    - path: "lib/cliff-detection.js"
      provides: "detectImplicitCliff, detectCompound, IMPLICIT_CLIFF_SIGNALS"
      exports: ["detectImplicitCliff", "detectCompound", "IMPLICIT_CLIFF_SIGNALS"]
    - path: "test/unit/cliff-detection.test.js"
      provides: "Unit tests for implicit and compound detection"
      min_lines: 150
  key_links:
    - from: "detectCompound"
      to: "detectExplicitCliff"
      via: "calls existing explicit detection first"
      pattern: "detectExplicitCliff\\(userResponse\\)"
    - from: "detectCompound"
      to: "detectImplicitCliff"
      via: "calls implicit detection for compound logic"
      pattern: "detectImplicitCliff\\(userResponse\\)"
---

<objective>
Extend cliff-detection.js with implicit signal detection and compound detection logic using TDD methodology.

Purpose: Enable detection of subtle uncertainty signals (hedging, quality degradation, deferrals) that indicate users approaching knowledge limits without explicit admission. Compound detection prevents false positives by requiring 2+ implicit signals.

Output: Extended lib/cliff-detection.js with detectImplicitCliff() and detectCompound() functions, plus comprehensive unit tests.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-polish-advanced-detection/15-RESEARCH.md

# Existing implementation to extend
@lib/cliff-detection.js
@test/unit/cliff-detection.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD Implicit Signal Detection</name>
  <files>lib/cliff-detection.js, test/unit/cliff-detection.test.js</files>
  <action>
Follow TDD RED-GREEN-REFACTOR cycle for implicit signal detection.

**RED Phase - Write failing tests first:**

Add new test block in test/unit/cliff-detection.test.js:

```javascript
import { detectImplicitCliff, IMPLICIT_CLIFF_SIGNALS } from '../../lib/cliff-detection.js';

describe('IMPLICIT_CLIFF_SIGNALS', () => {
  it('contains hedging signals', () => {
    assert.ok(IMPLICIT_CLIFF_SIGNALS.hedging.includes('maybe'));
    assert.ok(IMPLICIT_CLIFF_SIGNALS.hedging.includes('perhaps'));
    assert.ok(IMPLICIT_CLIFF_SIGNALS.hedging.includes('i guess'));
  });

  it('contains quality degradation markers', () => {
    assert.ok(IMPLICIT_CLIFF_SIGNALS.quality_markers.includes('um'));
    assert.ok(IMPLICIT_CLIFF_SIGNALS.quality_markers.includes('hmm'));
    assert.ok(IMPLICIT_CLIFF_SIGNALS.quality_markers.includes("let me think"));
  });

  it('contains deferral signals', () => {
    assert.ok(IMPLICIT_CLIFF_SIGNALS.deferrals.includes('whatever works'));
    assert.ok(IMPLICIT_CLIFF_SIGNALS.deferrals.includes('you pick'));
  });
});

describe('detectImplicitCliff', () => {
  it('detects hedging language', () => {
    const result = detectImplicitCliff("Maybe we should use PostgreSQL");
    assert.strictEqual(result.detected, true);
    assert.strictEqual(result.signals[0].category, 'hedging');
    assert.strictEqual(result.signals[0].confidence, 'MEDIUM');
  });

  it('detects quality degradation markers', () => {
    const result = detectImplicitCliff("Um, let me think about that");
    assert.strictEqual(result.detected, true);
    assert.ok(result.signals.some(s => s.category === 'quality_degradation'));
  });

  it('detects deferral patterns', () => {
    const result = detectImplicitCliff("Whatever works, you pick");
    assert.strictEqual(result.detected, true);
    assert.ok(result.signals.some(s => s.category === 'deferral'));
  });

  it('returns multiple signals if present', () => {
    const result = detectImplicitCliff("Maybe, um, whatever works I guess");
    assert.ok(result.signals.length >= 2);
  });

  it('returns detected: false for confident responses', () => {
    const result = detectImplicitCliff("I want PostgreSQL with Redis caching");
    assert.strictEqual(result.detected, false);
    assert.strictEqual(result.signals.length, 0);
  });

  it('is case insensitive', () => {
    const result = detectImplicitCliff("MAYBE we should use React");
    assert.strictEqual(result.detected, true);
  });

  it('preserves original response', () => {
    const original = "Maybe PostgreSQL?";
    const result = detectImplicitCliff(original);
    assert.strictEqual(result.originalResponse, original);
  });
});
```

Run tests - they should FAIL (detectImplicitCliff not exported).

Commit: `test(15-01): RED - add failing tests for implicit cliff detection`

**GREEN Phase - Implement to pass:**

Add to lib/cliff-detection.js:

```javascript
/**
 * Implicit cliff signal phrases organized by category (MEDIUM confidence)
 * Require compound detection (2+ signals) before triggering mode switch
 */
export const IMPLICIT_CLIFF_SIGNALS = {
  hedging: [
    "maybe", "perhaps", "possibly", "i guess", "i think maybe",
    "not sure if", "could be", "might be", "probably", "i suppose"
  ],
  quality_markers: [
    "um", "uh", "hmm", "well...", "let me think",
    "that's a good question", "honestly i'm not"
  ],
  deferrals: [
    "i'll figure it out later", "we can decide later",
    "whatever works", "whatever is easier", "any of those",
    "you pick", "dealer's choice"
  ]
};

/**
 * Detect implicit cliff signals in user response
 * @param {string} userResponse - User's response text
 * @returns {object} Detection result with detected, signals array, confidence, originalResponse
 */
export function detectImplicitCliff(userResponse) {
  const normalized = userResponse.toLowerCase().trim();
  const detected = [];

  // Check hedging patterns
  for (const signal of IMPLICIT_CLIFF_SIGNALS.hedging) {
    if (normalized.includes(signal)) {
      detected.push({
        signal,
        category: 'hedging',
        confidence: 'MEDIUM'
      });
    }
  }

  // Check quality degradation patterns
  for (const signal of IMPLICIT_CLIFF_SIGNALS.quality_markers) {
    if (normalized.includes(signal)) {
      detected.push({
        signal,
        category: 'quality_degradation',
        confidence: 'MEDIUM'
      });
    }
  }

  // Check deferral patterns
  for (const signal of IMPLICIT_CLIFF_SIGNALS.deferrals) {
    if (normalized.includes(signal)) {
      detected.push({
        signal,
        category: 'deferral',
        confidence: 'MEDIUM'
      });
    }
  }

  return {
    detected: detected.length > 0,
    signals: detected,
    confidence: detected.length > 0 ? 'MEDIUM' : null,
    originalResponse: userResponse
  };
}
```

Run tests - they should PASS.

Commit: `feat(15-01): GREEN - implement implicit cliff detection`
  </action>
  <verify>npm test -- --test-name-pattern="detectImplicitCliff" passes all new tests</verify>
  <done>detectImplicitCliff function detects hedging, quality markers, and deferrals with MEDIUM confidence and returns structured result</done>
</task>

<task type="auto">
  <name>Task 2: TDD Compound Detection Logic</name>
  <files>lib/cliff-detection.js, test/unit/cliff-detection.test.js</files>
  <action>
Follow TDD RED-GREEN-REFACTOR cycle for compound detection.

**RED Phase - Write failing tests first:**

Add to test/unit/cliff-detection.test.js:

```javascript
import { detectCompound } from '../../lib/cliff-detection.js';

describe('detectCompound', () => {
  it('triggers immediately on explicit signal', () => {
    const result = detectCompound("I don't know what to use");
    assert.strictEqual(result.trigger, true);
    assert.strictEqual(result.reason, 'explicit_signal');
    assert.strictEqual(result.confidence, 'HIGH');
  });

  it('does not trigger on single implicit signal', () => {
    const result = detectCompound("Maybe PostgreSQL");
    assert.strictEqual(result.trigger, false);
    assert.strictEqual(result.signalCount, 1);
  });

  it('triggers on 2+ implicit signals in current response', () => {
    const result = detectCompound("Um, maybe, whatever works");
    assert.strictEqual(result.trigger, true);
    assert.strictEqual(result.reason, 'compound_implicit');
    assert.strictEqual(result.confidence, 'MEDIUM');
    assert.ok(result.signalCount >= 2);
  });

  it('triggers when implicit signals accumulate across history', () => {
    const history = [
      { implicitSignals: [{ signal: 'maybe', category: 'hedging' }] },
      { implicitSignals: [] }
    ];
    // Current response has 1 implicit, history has 1 = 2 total
    const result = detectCompound("I guess so", history);
    assert.strictEqual(result.trigger, true);
    assert.strictEqual(result.reason, 'compound_implicit');
  });

  it('uses only last 3 responses from history', () => {
    const history = [
      { implicitSignals: [{ signal: 'old1', category: 'hedging' }] }, // Too old
      { implicitSignals: [{ signal: 'old2', category: 'hedging' }] }, // Too old
      { implicitSignals: [] }, // -3
      { implicitSignals: [] }, // -2
      { implicitSignals: [] }  // -1
    ];
    // Only last 3 have 0 implicit signals, current has 1 = 1 total (no trigger)
    const result = detectCompound("Maybe", history);
    assert.strictEqual(result.trigger, false);
    assert.strictEqual(result.signalCount, 1);
  });

  it('returns detected signals array', () => {
    const result = detectCompound("Maybe, I guess, whatever");
    assert.ok(Array.isArray(result.signals));
    assert.ok(result.signals.length > 0);
  });

  it('does not trigger on confident response', () => {
    const result = detectCompound("Use PostgreSQL with Redis caching");
    assert.strictEqual(result.trigger, false);
    assert.strictEqual(result.signalCount, 0);
  });

  it('explicit signal takes priority over accumulated implicit', () => {
    const history = [
      { implicitSignals: [{ signal: 'maybe', category: 'hedging' }] },
      { implicitSignals: [{ signal: 'um', category: 'quality_degradation' }] }
    ];
    const result = detectCompound("I don't know", history);
    assert.strictEqual(result.trigger, true);
    assert.strictEqual(result.reason, 'explicit_signal');
    assert.strictEqual(result.confidence, 'HIGH');
  });
});
```

Run tests - they should FAIL (detectCompound not exported).

Commit: `test(15-01): RED - add failing tests for compound detection`

**GREEN Phase - Implement to pass:**

Add to lib/cliff-detection.js:

```javascript
/**
 * Detect cliff signals with compound logic
 * Explicit signals trigger immediately (HIGH confidence)
 * Implicit signals require 2+ across current + last 3 responses (MEDIUM confidence)
 *
 * @param {string} userResponse - User's response text
 * @param {Array} recentHistory - Last N responses with implicitSignals arrays
 * @returns {object} Detection result with trigger, reason, signalCount, confidence, signals
 */
export function detectCompound(userResponse, recentHistory = []) {
  const explicitResult = detectExplicitCliff(userResponse);
  const implicitResult = detectImplicitCliff(userResponse);

  // Explicit signals always trigger immediately (HIGH confidence)
  if (explicitResult.detected) {
    return {
      trigger: true,
      reason: 'explicit_signal',
      confidence: 'HIGH',
      signal: explicitResult.signal,
      signals: [{ signal: explicitResult.signal, category: 'explicit', confidence: 'HIGH' }],
      signalCount: 1,
      originalResponse: userResponse
    };
  }

  // Count implicit signals in current response
  const currentImplicitCount = implicitResult.signals.length;

  // Count implicit signals in recent history (last 3 responses only)
  const historyImplicitCount = recentHistory
    .slice(-3)
    .filter(r => r.implicitSignals && r.implicitSignals.length > 0)
    .reduce((sum, r) => sum + r.implicitSignals.length, 0);

  const totalImplicit = currentImplicitCount + historyImplicitCount;

  // Compound threshold: 2+ implicit signals needed
  if (totalImplicit >= 2) {
    return {
      trigger: true,
      reason: 'compound_implicit',
      signalCount: totalImplicit,
      confidence: 'MEDIUM',
      signals: implicitResult.signals,
      originalResponse: userResponse
    };
  }

  // Log detection but don't trigger
  return {
    trigger: false,
    signalCount: totalImplicit,
    signals: implicitResult.signals,
    originalResponse: userResponse
  };
}
```

Run tests - they should PASS.

Commit: `feat(15-01): GREEN - implement compound detection logic`

**REFACTOR Phase (if needed):**

Review implementation for any obvious improvements. If changes made, run tests to verify, then commit: `refactor(15-01): clean up compound detection`
  </action>
  <verify>npm test -- --test-name-pattern="detectCompound" passes all new tests</verify>
  <done>detectCompound function triggers immediately on explicit signals (HIGH) and requires 2+ implicit signals (MEDIUM) with history tracking</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Run full cliff detection test suite:
   ```bash
   npm test -- --test-name-pattern="cliff"
   ```
   Expected: All tests pass including new implicit and compound detection tests

2. Verify exports:
   ```bash
   node -e "import('./lib/cliff-detection.js').then(m => console.log(Object.keys(m)))"
   ```
   Expected: ['EXPLICIT_CLIFF_SIGNALS', 'detectExplicitCliff', 'IMPLICIT_CLIFF_SIGNALS', 'detectImplicitCliff', 'detectCompound']

3. Verify signal counts:
   - IMPLICIT_CLIFF_SIGNALS.hedging: 10 signals
   - IMPLICIT_CLIFF_SIGNALS.quality_markers: 7 signals
   - IMPLICIT_CLIFF_SIGNALS.deferrals: 7 signals
</verification>

<success_criteria>
- [ ] detectImplicitCliff exported and detects hedging, quality markers, deferrals
- [ ] IMPLICIT_CLIFF_SIGNALS constant exported with 3 categories
- [ ] detectCompound exported with compound threshold logic
- [ ] Explicit signals still trigger immediately with HIGH confidence
- [ ] 2+ implicit signals required for compound trigger
- [ ] History tracking uses last 3 responses only
- [ ] All unit tests pass
- [ ] TDD commits follow RED-GREEN pattern
</success_criteria>

<output>
After completion, create `.planning/phases/15-polish-advanced-detection/15-01-SUMMARY.md`
</output>
