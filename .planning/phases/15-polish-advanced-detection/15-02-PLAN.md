---
phase: 15-polish-advanced-detection
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/complexity-ceiling.js
  - test/unit/complexity-ceiling.test.js
autonomous: true

must_haves:
  truths:
    - "Project constraints are extracted from survey and surveyor_notes"
    - "Solo developer, budget constrained, and time constrained projects are identified"
    - "Complexity ceiling is set to 'minimal' for constrained projects"
    - "Over-engineering patterns are flagged with warnings but not blocked"
  artifacts:
    - path: "lib/complexity-ceiling.js"
      provides: "extractConstraints, checkComplexity, COMPLEXITY_INDICATORS"
      exports: ["extractConstraints", "checkComplexity", "COMPLEXITY_INDICATORS"]
    - path: "test/unit/complexity-ceiling.test.js"
      provides: "Unit tests for constraint extraction and complexity checking"
      min_lines: 100
  key_links:
    - from: "extractConstraints"
      to: "survey.project"
      via: "reads project description for constraint indicators"
      pattern: "survey\\.project"
    - from: "checkComplexity"
      to: "COMPLEXITY_INDICATORS"
      via: "uses indicator patterns for violation detection"
      pattern: "COMPLEXITY_INDICATORS"
---

<objective>
Create complexity ceiling module using TDD methodology to prevent over-engineering recommendations for constrained projects.

Purpose: Enforce right-sized engineering recommendations by extracting project constraints (solo developer, budget, timeline, experience) and flagging over-complex solutions like microservices or Kubernetes for MVP/solo projects.

Output: New lib/complexity-ceiling.js module with extractConstraints() and checkComplexity() functions, plus comprehensive unit tests.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-polish-advanced-detection/15-RESEARCH.md

# Reference for existing test patterns
@test/unit/cliff-detection.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD Constraint Extraction</name>
  <files>lib/complexity-ceiling.js, test/unit/complexity-ceiling.test.js</files>
  <action>
Follow TDD RED-GREEN-REFACTOR cycle for constraint extraction.

**RED Phase - Write failing tests first:**

Create test/unit/complexity-ceiling.test.js:

```javascript
/**
 * Tests for lib/complexity-ceiling.js - Complexity ceiling enforcement
 */

import { describe, it } from 'node:test';
import assert from 'node:assert';
import { extractConstraints, COMPLEXITY_INDICATORS } from '../../lib/complexity-ceiling.js';

describe('COMPLEXITY_INDICATORS', () => {
  it('contains solo developer indicators', () => {
    assert.ok(COMPLEXITY_INDICATORS.solo_developer.includes('solo'));
    assert.ok(COMPLEXITY_INDICATORS.solo_developer.includes('just me'));
    assert.ok(COMPLEXITY_INDICATORS.solo_developer.includes('side project'));
  });

  it('contains budget constraint indicators', () => {
    assert.ok(COMPLEXITY_INDICATORS.budget_constrained.includes('budget'));
    assert.ok(COMPLEXITY_INDICATORS.budget_constrained.includes('free tier'));
  });

  it('contains time constraint indicators', () => {
    assert.ok(COMPLEXITY_INDICATORS.time_constrained.includes('mvp'));
    assert.ok(COMPLEXITY_INDICATORS.time_constrained.includes('prototype'));
  });

  it('contains experience level indicators', () => {
    assert.ok(COMPLEXITY_INDICATORS.experience_level.beginner.includes('first time'));
    assert.ok(COMPLEXITY_INDICATORS.experience_level.intermediate.includes('some experience'));
  });
});

describe('extractConstraints', () => {
  it('returns default constraints for empty survey', () => {
    const result = extractConstraints({});
    assert.strictEqual(result.teamSize, 'unknown');
    assert.strictEqual(result.budget, 'unknown');
    assert.strictEqual(result.timeline, 'unknown');
    assert.strictEqual(result.experience, 'unknown');
    assert.strictEqual(result.maxComplexity, 'standard');
  });

  it('detects solo developer from project description', () => {
    const survey = {
      project: { one_liner: "A side project I'm building by myself" }
    };
    const result = extractConstraints(survey);
    assert.strictEqual(result.teamSize, 'solo');
    assert.strictEqual(result.maxComplexity, 'minimal');
  });

  it('detects budget constraints from surveyor notes', () => {
    const survey = { project: { name: 'Test' } };
    const surveyorNotes = {
      implicit_constraints: ["User mentioned wanting to stay on free tier"]
    };
    const result = extractConstraints(survey, surveyorNotes);
    assert.strictEqual(result.budget, 'constrained');
    assert.strictEqual(result.maxComplexity, 'minimal');
  });

  it('detects MVP/prototype timeline', () => {
    const survey = {
      project: { one_liner: "Building an MVP to validate the idea" }
    };
    const result = extractConstraints(survey);
    assert.strictEqual(result.timeline, 'fast');
    assert.strictEqual(result.maxComplexity, 'minimal');
  });

  it('detects beginner experience from surveyor notes', () => {
    const survey = { project: { name: 'Test' } };
    const surveyorNotes = {
      implicit_constraints: ["This is my first time building a backend"]
    };
    const result = extractConstraints(survey, surveyorNotes);
    assert.strictEqual(result.experience, 'beginner');
  });

  it('handles missing surveyor notes gracefully', () => {
    const survey = { project: { name: 'Test', one_liner: 'Enterprise app' } };
    const result = extractConstraints(survey, null);
    assert.strictEqual(result.maxComplexity, 'standard');
  });

  it('combines multiple constraints', () => {
    const survey = {
      project: { one_liner: "Solo MVP project on a budget" }
    };
    const surveyorNotes = {
      implicit_constraints: ["Wants to stay on free tier", "Just me working on this"]
    };
    const result = extractConstraints(survey, surveyorNotes);
    assert.strictEqual(result.teamSize, 'solo');
    assert.strictEqual(result.budget, 'constrained');
    assert.strictEqual(result.timeline, 'fast');
    assert.strictEqual(result.maxComplexity, 'minimal');
  });
});
```

Run tests - they should FAIL (module doesn't exist).

Commit: `test(15-02): RED - add failing tests for constraint extraction`

**GREEN Phase - Implement to pass:**

Create lib/complexity-ceiling.js:

```javascript
/**
 * Complexity ceiling module for Banneker engineer recommendations
 * Prevents over-engineering by extracting project constraints and validating recommendations
 */

/**
 * Indicators used to detect project constraints from survey text
 */
export const COMPLEXITY_INDICATORS = {
  solo_developer: ['solo', 'just me', 'one person', 'by myself', 'side project', 'personal project'],
  budget_constrained: ['budget', 'cost', 'cheap', 'free tier', 'limited resources', 'affordable'],
  time_constrained: ['quick', 'fast', 'mvp', 'prototype', 'deadline', 'asap', 'sprint'],
  experience_level: {
    beginner: ['first time', 'learning', 'new to', 'beginner', 'never used', 'just started'],
    intermediate: ['some experience', 'used before', 'familiar with', 'worked with'],
    expert: ['expert', 'years of experience', 'production at scale', 'senior']
  }
};

/**
 * Extract project constraints from survey data and surveyor notes
 * @param {object} survey - Survey JSON data
 * @param {object} surveyorNotes - Optional surveyor handoff notes
 * @returns {object} Constraints with teamSize, budget, timeline, experience, maxComplexity
 */
export function extractConstraints(survey, surveyorNotes = null) {
  const constraints = {
    teamSize: 'unknown',
    budget: 'unknown',
    timeline: 'unknown',
    experience: 'unknown',
    maxComplexity: 'standard' // standard | minimal | enterprise
  };

  // Collect all text to analyze
  const textsToAnalyze = [];

  // Add project description
  if (survey?.project?.one_liner) {
    textsToAnalyze.push(survey.project.one_liner.toLowerCase());
  }
  if (survey?.project?.problem_statement) {
    textsToAnalyze.push(survey.project.problem_statement.toLowerCase());
  }

  // Add surveyor notes constraints
  if (surveyorNotes?.implicit_constraints) {
    for (const constraint of surveyorNotes.implicit_constraints) {
      textsToAnalyze.push(constraint.toLowerCase());
    }
  }

  // Analyze all collected text
  const allText = textsToAnalyze.join(' ');

  // Check for solo developer
  if (COMPLEXITY_INDICATORS.solo_developer.some(s => allText.includes(s))) {
    constraints.teamSize = 'solo';
    constraints.maxComplexity = 'minimal';
  }

  // Check for budget constraints
  if (COMPLEXITY_INDICATORS.budget_constrained.some(s => allText.includes(s))) {
    constraints.budget = 'constrained';
    constraints.maxComplexity = 'minimal';
  }

  // Check for time constraints (MVP/prototype)
  if (COMPLEXITY_INDICATORS.time_constrained.some(s => allText.includes(s))) {
    constraints.timeline = 'fast';
    constraints.maxComplexity = 'minimal';
  }

  // Check experience level
  if (COMPLEXITY_INDICATORS.experience_level.beginner.some(s => allText.includes(s))) {
    constraints.experience = 'beginner';
  } else if (COMPLEXITY_INDICATORS.experience_level.intermediate.some(s => allText.includes(s))) {
    constraints.experience = 'intermediate';
  } else if (COMPLEXITY_INDICATORS.experience_level.expert.some(s => allText.includes(s))) {
    constraints.experience = 'expert';
  }

  return constraints;
}
```

Run tests - they should PASS.

Commit: `feat(15-02): GREEN - implement constraint extraction`
  </action>
  <verify>npm test -- --test-name-pattern="extractConstraints" passes all new tests</verify>
  <done>extractConstraints function detects solo, budget, timeline, and experience constraints and sets maxComplexity accordingly</done>
</task>

<task type="auto">
  <name>Task 2: TDD Complexity Checking</name>
  <files>lib/complexity-ceiling.js, test/unit/complexity-ceiling.test.js</files>
  <action>
Follow TDD RED-GREEN-REFACTOR cycle for complexity checking.

**RED Phase - Write failing tests first:**

Add to test/unit/complexity-ceiling.test.js:

```javascript
import { checkComplexity } from '../../lib/complexity-ceiling.js';

describe('checkComplexity', () => {
  it('returns valid: true for standard complexity', () => {
    const constraints = { maxComplexity: 'standard' };
    const recommendation = "Use microservices with Kubernetes";
    const result = checkComplexity(recommendation, constraints);
    assert.strictEqual(result.valid, true);
    assert.strictEqual(result.violations.length, 0);
  });

  it('flags microservices for minimal complexity', () => {
    const constraints = { maxComplexity: 'minimal' };
    const recommendation = "Deploy as microservices architecture";
    const result = checkComplexity(recommendation, constraints);
    assert.strictEqual(result.valid, false);
    assert.ok(result.violations.length > 0);
    assert.ok(result.violations[0].type === 'over_engineering');
    assert.ok(result.violations[0].reason.includes('Microservice'));
  });

  it('flags Kubernetes for minimal complexity', () => {
    const constraints = { maxComplexity: 'minimal' };
    const recommendation = "Deploy to Kubernetes cluster";
    const result = checkComplexity(recommendation, constraints);
    assert.strictEqual(result.valid, false);
    assert.ok(result.violations.some(v => v.reason.includes('K8s')));
  });

  it('flags event-driven architecture for MVP', () => {
    const constraints = { maxComplexity: 'minimal' };
    const recommendation = "Use event-driven architecture with message queues";
    const result = checkComplexity(recommendation, constraints);
    assert.strictEqual(result.valid, false);
    assert.ok(result.violations.some(v => v.reason.includes('Event-driven')));
  });

  it('flags distributed systems for solo projects', () => {
    const constraints = { maxComplexity: 'minimal' };
    const recommendation = "Build a distributed system with consensus";
    const result = checkComplexity(recommendation, constraints);
    assert.strictEqual(result.valid, false);
    assert.ok(result.violations.some(v => v.reason.includes('Distributed')));
  });

  it('allows simple stack for minimal complexity', () => {
    const constraints = { maxComplexity: 'minimal' };
    const recommendation = "Use Next.js with PostgreSQL deployed on Vercel";
    const result = checkComplexity(recommendation, constraints);
    assert.strictEqual(result.valid, true);
    assert.strictEqual(result.violations.length, 0);
  });

  it('returns suggestions in violations', () => {
    const constraints = { maxComplexity: 'minimal' };
    const recommendation = "Use microservices";
    const result = checkComplexity(recommendation, constraints);
    assert.ok(result.violations[0].suggestion);
    assert.ok(result.violations[0].suggestion.includes('monolithic'));
  });

  it('detects multiple violations', () => {
    const constraints = { maxComplexity: 'minimal' };
    const recommendation = "Deploy microservices on Kubernetes with event-driven patterns";
    const result = checkComplexity(recommendation, constraints);
    assert.ok(result.violations.length >= 2);
  });
});
```

Run tests - they should FAIL (checkComplexity not exported).

Commit: `test(15-02): RED - add failing tests for complexity checking`

**GREEN Phase - Implement to pass:**

Add to lib/complexity-ceiling.js:

```javascript
/**
 * Check if recommendation exceeds complexity ceiling
 * @param {string} recommendation - Recommendation text to check
 * @param {object} constraints - Constraints from extractConstraints()
 * @returns {object} Result with valid boolean and violations array
 */
export function checkComplexity(recommendation, constraints) {
  const violations = [];

  // Only enforce ceiling for minimal complexity projects
  if (constraints.maxComplexity !== 'minimal') {
    return { valid: true, violations: [] };
  }

  // Over-engineering patterns to flag for minimal complexity projects
  const overEngineeredPatterns = [
    {
      pattern: /microservice/i,
      reason: 'Microservices over-complex for solo/MVP',
      suggestion: 'Consider simpler monolithic approach'
    },
    {
      pattern: /kubernetes|k8s/i,
      reason: 'K8s over-complex for solo/MVP',
      suggestion: 'Consider simpler monolithic approach with managed hosting (Vercel, Railway)'
    },
    {
      pattern: /event.?driven.*architecture/i,
      reason: 'Event-driven architecture over-complex for MVP',
      suggestion: 'Consider simpler monolithic approach with request/response patterns'
    },
    {
      pattern: /distributed.*system/i,
      reason: 'Distributed systems over-complex for solo',
      suggestion: 'Consider simpler monolithic approach'
    }
  ];

  for (const { pattern, reason, suggestion } of overEngineeredPatterns) {
    if (pattern.test(recommendation)) {
      violations.push({
        type: 'over_engineering',
        reason,
        suggestion
      });
    }
  }

  return {
    valid: violations.length === 0,
    violations
  };
}
```

Run tests - they should PASS.

Commit: `feat(15-02): GREEN - implement complexity checking`

**REFACTOR Phase (if needed):**

Review implementation. If any improvements, run tests and commit: `refactor(15-02): clean up complexity ceiling`
  </action>
  <verify>npm test -- --test-name-pattern="checkComplexity" passes all new tests</verify>
  <done>checkComplexity function flags over-engineering patterns for minimal complexity projects with warnings and suggestions</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Run full complexity ceiling test suite:
   ```bash
   npm test -- --test-name-pattern="complexity"
   ```
   Expected: All tests pass

2. Verify exports:
   ```bash
   node -e "import('./lib/complexity-ceiling.js').then(m => console.log(Object.keys(m)))"
   ```
   Expected: ['COMPLEXITY_INDICATORS', 'extractConstraints', 'checkComplexity']

3. Verify indicator counts:
   - solo_developer: 6 indicators
   - budget_constrained: 6 indicators
   - time_constrained: 7 indicators

4. Verify constraint detection works end-to-end:
   ```javascript
   const survey = { project: { one_liner: "Solo MVP on budget" } };
   const constraints = extractConstraints(survey);
   console.log(constraints.maxComplexity); // Should be 'minimal'

   const result = checkComplexity("Use Kubernetes", constraints);
   console.log(result.valid); // Should be false
   ```
</verification>

<success_criteria>
- [ ] COMPLEXITY_INDICATORS constant exported with all categories
- [ ] extractConstraints exported and detects solo, budget, time, experience constraints
- [ ] checkComplexity exported and flags over-engineering for minimal complexity
- [ ] Violations include type, reason, and suggestion
- [ ] Standard complexity allows all patterns (no false positives)
- [ ] All unit tests pass
- [ ] TDD commits follow RED-GREEN pattern
</success_criteria>

<output>
After completion, create `.planning/phases/15-polish-advanced-detection/15-02-SUMMARY.md`
</output>
