---
phase: 15-polish-advanced-detection
plan: 04
type: execute
wave: 2
depends_on: ["15-02"]
files_modified:
  - templates/agents/banneker-engineer.md
  - lib/research-integration.js
autonomous: true

must_haves:
  truths:
    - "Engineer extracts project constraints and applies complexity ceiling"
    - "Over-engineering violations are flagged in RECOMMENDATION.md"
    - "Research-on-demand identifies gaps that could be filled via WebSearch"
    - "Research queries are limited to 3 per session"
  artifacts:
    - path: "templates/agents/banneker-engineer.md"
      provides: "Updated engineer with complexity ceiling and research integration"
      contains: "Complexity Assessment"
    - path: "lib/research-integration.js"
      provides: "Research gap identification module"
      exports: ["identifyResearchableGaps", "buildSearchQuery"]
  key_links:
    - from: "templates/agents/banneker-engineer.md"
      to: "lib/complexity-ceiling.js"
      via: "imports extractConstraints and checkComplexity"
      pattern: "extractConstraints|checkComplexity"
    - from: "templates/agents/banneker-engineer.md"
      to: "lib/research-integration.js"
      via: "imports identifyResearchableGaps for gap filling"
      pattern: "identifyResearchableGaps"
---

<objective>
Integrate complexity ceiling enforcement and research-on-demand capability into the engineer agent.

Purpose: Prevent over-engineering recommendations for constrained projects (solo, MVP, budget-limited) and enable research via WebSearch to fill knowledge gaps during synthesis, improving recommendation confidence.

Output: Updated banneker-engineer.md with complexity assessment section and research integration, plus new lib/research-integration.js module.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-polish-advanced-detection/15-RESEARCH.md
@.planning/phases/15-polish-advanced-detection/15-02-SUMMARY.md

# Existing files to modify
@templates/agents/banneker-engineer.md
@lib/complexity-ceiling.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Research Integration Module</name>
  <files>lib/research-integration.js</files>
  <action>
Create lib/research-integration.js for identifying researchable gaps.

```javascript
/**
 * Research integration module for Banneker engineer
 * Identifies gaps that could be filled via WebSearch research
 */

/**
 * Keywords that indicate a gap could be filled with research
 */
const RESEARCHABLE_INDICATORS = [
  'best practices',
  'recommended',
  'industry standard',
  'current approach',
  'comparison',
  'vs',
  'alternatives',
  'trade-offs',
  'modern approach',
  'state of the art'
];

/**
 * Identify gaps from DIAGNOSIS that could be filled with research
 * @param {Array<string>} diagnosisGaps - Gaps identified in DIAGNOSIS.md
 * @returns {Array<object>} Researchable gaps with search queries
 */
export function identifyResearchableGaps(diagnosisGaps) {
  const researchable = [];

  for (const gap of diagnosisGaps) {
    const gapLower = gap.toLowerCase();

    // Check if gap mentions researchable topics
    const isResearchable = RESEARCHABLE_INDICATORS.some(indicator =>
      gapLower.includes(indicator)
    );

    // Also check for technology comparison gaps
    const isTechComparison = /\bvs\b|comparison|which.*(?:to use|better)|choose between/i.test(gap);

    if (isResearchable || isTechComparison) {
      researchable.push({
        gap,
        searchQuery: buildSearchQuery(gap),
        priority: isTechComparison ? 'high' : 'medium',
        type: isTechComparison ? 'technology_comparison' : 'best_practices'
      });
    }
  }

  // Sort by priority (high first), limit to top 3
  return researchable
    .sort((a, b) => a.priority === 'high' ? -1 : 1)
    .slice(0, 3);
}

/**
 * Build a search query from a gap description
 * @param {string} gap - Gap description text
 * @returns {string} Search query for WebSearch
 */
export function buildSearchQuery(gap) {
  // Clean up gap text
  const cleaned = gap
    // Remove survey path notation
    .replace(/backend\.|frontend\.|survey\.|rubric_coverage\./g, '')
    // Remove common gap descriptors
    .replace(/not.?captured|missing|gap|unknown|unspecified/gi, '')
    // Remove extra whitespace
    .replace(/\s+/g, ' ')
    .trim();

  // Add freshness indicator (current year)
  const year = new Date().getFullYear();
  return `${cleaned} best practices ${year}`;
}

/**
 * Format research results for inclusion in RECOMMENDATION.md
 * @param {object} researchResult - Result from WebSearch
 * @param {string} originalGap - The gap this research addresses
 * @returns {string} Formatted markdown section
 */
export function formatResearchFindings(researchResult, originalGap) {
  return `
### Research Findings

**Gap addressed:** ${originalGap}
**Query:** ${researchResult.query}
**Source:** ${researchResult.source || 'WebSearch'}

**Key findings:**
${researchResult.findings || 'No specific findings extracted'}

**Impact on recommendation:**
${researchResult.impact || 'Research findings incorporated into recommendation confidence.'}

---
`;
}
```
  </action>
  <verify>node -e "import('./lib/research-integration.js').then(m => console.log(Object.keys(m)))" outputs identifyResearchableGaps, buildSearchQuery, formatResearchFindings</verify>
  <done>Research integration module exports functions to identify researchable gaps and build search queries</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Complexity Ceiling into Engineer</name>
  <files>templates/agents/banneker-engineer.md</files>
  <action>
Update the engineer agent to use complexity ceiling for recommendations.

**1. Add complexity assessment to Step 2 (after survey analysis):**

Find the section after survey completeness analysis and add:

```markdown
### Step 2b: Extract Project Constraints

After analyzing survey completeness, extract project constraints for complexity ceiling:

```javascript
// Import from complexity-ceiling.js
const { extractConstraints, checkComplexity, COMPLEXITY_INDICATORS } = require('../lib/complexity-ceiling.js');

// Extract constraints from survey and surveyor notes
const surveyorNotes = survey.surveyor_notes || null;
const constraints = extractConstraints(survey, surveyorNotes);

// Store for use in RECOMMENDATION generation
state.constraints = constraints;

console.log('Project Constraints:');
console.log(`  Team Size: ${constraints.teamSize}`);
console.log(`  Budget: ${constraints.budget}`);
console.log(`  Timeline: ${constraints.timeline}`);
console.log(`  Experience: ${constraints.experience}`);
console.log(`  Complexity Ceiling: ${constraints.maxComplexity}`);
```

**Constraint Indicators:**
- **Solo developer:** "solo", "just me", "one person", "by myself", "side project"
- **Budget constrained:** "budget", "cost", "cheap", "free tier", "limited resources"
- **Time constrained:** "quick", "fast", "mvp", "prototype", "deadline"
- **Experience:** beginner/intermediate/expert indicators

**Ceiling Assignment:**
- If ANY constraint indicator detected -> `maxComplexity: 'minimal'`
- Otherwise -> `maxComplexity: 'standard'`
```

**2. Add complexity check during RECOMMENDATION generation:**

Find the RECOMMENDATION generation section and add complexity validation:

```markdown
### Check Recommendations Against Complexity Ceiling

For each recommendation generated, validate against complexity ceiling:

```javascript
function validateRecommendation(recommendationText, constraints) {
  const result = checkComplexity(recommendationText, constraints);

  if (!result.valid) {
    // Flag but don't block - user can override
    return {
      recommendation: recommendationText,
      violations: result.violations,
      warning: true
    };
  }

  return {
    recommendation: recommendationText,
    violations: [],
    warning: false
  };
}
```

**Over-engineering patterns flagged for minimal complexity:**
- Microservices architecture
- Kubernetes/K8s deployment
- Event-driven architecture
- Distributed systems
```

**3. Add Complexity Assessment section to RECOMMENDATION.md template:**

Find the RECOMMENDATION.md document structure and add new section before the recommendations:

```markdown
## Complexity Assessment

**Extracted Constraints:**
- **Team size:** [constraints.teamSize] [inference note if applicable]
- **Budget:** [constraints.budget] [inference note if applicable]
- **Timeline:** [constraints.timeline] [inference note if applicable]
- **Experience:** [constraints.experience] [inference note if applicable]

**Complexity Ceiling:** [constraints.maxComplexity | uppercase]

[If maxComplexity === 'minimal':]

### Recommendations Flagged for Review

The following recommendations may exceed the minimal complexity ceiling based on detected project constraints:

| Recommendation | Issue | Alternative Suggested |
|----------------|-------|----------------------|
| [recommendation area] | [violation.reason] | [violation.suggestion] |

**Note:** These recommendations are flagged, not blocked. If you have specific reasons for these choices (learning goals, future scaling requirements, existing expertise), you may proceed with acknowledgment.

[If maxComplexity === 'standard':]

No complexity ceiling enforced. All recommendations are valid for standard complexity projects.
```

**4. Modify recommendation output to include warnings:**

```markdown
### Recommendation Output Format (with ceiling)

For each recommendation section, if violations exist:

```markdown
## [Area]: [Recommendation]

> **Complexity Warning:** This recommendation exceeds the minimal complexity ceiling.
> - **Issue:** [violation.reason]
> - **Suggested Alternative:** [violation.suggestion]
>
> Proceed if you have specific requirements that justify this complexity.

### Analysis
...
```
```
  </action>
  <verify>grep -c "Complexity Assessment\|extractConstraints\|checkComplexity" templates/agents/banneker-engineer.md returns at least 3 matches</verify>
  <done>Engineer extracts constraints, validates recommendations against ceiling, and includes Complexity Assessment section in RECOMMENDATION.md</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Research-on-Demand into Engineer</name>
  <files>templates/agents/banneker-engineer.md</files>
  <action>
Update the engineer agent to trigger research for fillable gaps.

**1. Add research integration to RECOMMENDATION generation:**

Find the RECOMMENDATION generation section and add research capability:

```markdown
### Step 4b: Research-on-Demand for Gaps

Before generating recommendations for LOW confidence areas, check if research could help:

```javascript
// Import research integration
const { identifyResearchableGaps, buildSearchQuery, formatResearchFindings } = require('../lib/research-integration.js');

// Get gaps from DIAGNOSIS
const diagnosisGaps = completenessAnalysis.gaps;

// Identify which gaps could be filled with research
const researchableGaps = identifyResearchableGaps(diagnosisGaps);

// Limit to 3 research queries per session (context budget)
const researchLimit = 3;
state.researchQueriesUsed = state.researchQueriesUsed || 0;

console.log(`Researchable gaps: ${researchableGaps.length}`);
console.log(`Research budget: ${researchLimit - state.researchQueriesUsed} queries remaining`);
```

**Research Triggers:**
1. Gap mentions "best practices", "recommended", "industry standard"
2. Gap involves technology comparison ("vs", "comparison", "which to use")
3. Recommendation would be LOW confidence without additional information

**Research Limits:**
- Maximum 3 WebSearch queries per engineer session
- Only trigger for HIGH priority gaps (technology comparisons) first
- Skip research if survey completeness > 70% (probably enough info)

### Executing Research

When research is warranted:

```javascript
if (researchableGaps.length > 0 && state.researchQueriesUsed < researchLimit) {
  for (const { gap, searchQuery, priority } of researchableGaps) {
    if (state.researchQueriesUsed >= researchLimit) break;

    // Use WebFetch tool for research
    // The executor should use the WebFetch tool with the query
    console.log(`Researching: ${searchQuery}`);

    // In practice, the agent would call:
    // const result = await WebFetch({ url: searchUrl, prompt: "Extract key recommendations" });

    state.researchQueriesUsed++;
    state.researchFindings = state.researchFindings || [];
    state.researchFindings.push({
      gap,
      query: searchQuery,
      // findings will be populated from WebFetch result
    });
  }
}
```

**When to Research:**
- Survey completeness < 70%
- Gap is technology comparison (priority: high)
- No existing decision covers this area
- Would significantly improve confidence

**When to Skip Research:**
- Survey completeness >= 70%
- Gap is project-specific (can't be researched)
- Research budget exhausted
- User explicitly deferred this topic
```

**2. Add research findings to RECOMMENDATION.md:**

```markdown
### Including Research Findings

If research was performed, add findings section to relevant recommendation:

```markdown
## [Area]: [Recommendation]

### Research Conducted

**Query:** "[search query]"
**Gap addressed:** [original gap from DIAGNOSIS]

**Key findings:**
- [finding 1]
- [finding 2]

**How this affected the recommendation:**
[Explanation of how research improved confidence or changed recommendation]

### Analysis
...
```

**Research Impact on Confidence:**
- Research findings that confirm recommendation: Boost confidence by one level (LOW -> MEDIUM)
- Research findings that conflict: Note disagreement, keep at original confidence
- No relevant findings: Keep at original confidence, note research was inconclusive
```

**3. Add research tracking to engineer-state.md:**

```markdown
### Research State Tracking

Track research queries in engineer-state.md:

```markdown
## Research Activity

**Queries used:** 2/3
**Queries remaining:** 1

### Research Log

| Query | Gap Addressed | Status | Finding Summary |
|-------|---------------|--------|-----------------|
| "react vs vue 2026 best practices" | frontend framework comparison | completed | React ecosystem larger |
| "postgresql vs mongodb 2026" | database choice | completed | PostgreSQL for relational |

### Impact on Recommendations

| Recommendation | Original Confidence | Post-Research Confidence |
|----------------|---------------------|--------------------------|
| Frontend Framework | LOW | MEDIUM |
| Database | LOW | MEDIUM |
```
```
  </action>
  <verify>grep -c "identifyResearchableGaps\|Research-on-Demand\|researchQueriesUsed" templates/agents/banneker-engineer.md returns at least 3 matches</verify>
  <done>Engineer identifies researchable gaps, triggers WebSearch within limits, and integrates findings into recommendations</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify research module exports:
   ```bash
   node -e "import('./lib/research-integration.js').then(m => console.log(Object.keys(m)))"
   ```
   Expected: ['identifyResearchableGaps', 'buildSearchQuery', 'formatResearchFindings']

2. Verify engineer has complexity integration:
   ```bash
   grep "extractConstraints" templates/agents/banneker-engineer.md
   grep "Complexity Assessment" templates/agents/banneker-engineer.md
   ```
   Expected: Matches in both

3. Verify engineer has research integration:
   ```bash
   grep "identifyResearchableGaps" templates/agents/banneker-engineer.md
   grep "researchQueriesUsed" templates/agents/banneker-engineer.md
   ```
   Expected: Matches for both

4. Verify research limit documented:
   ```bash
   grep "3.*queries\|queries.*3" templates/agents/banneker-engineer.md
   ```
   Expected: Match for 3 query limit
</verification>

<success_criteria>
- [ ] lib/research-integration.js created with identifyResearchableGaps, buildSearchQuery, formatResearchFindings
- [ ] Engineer extracts constraints using extractConstraints()
- [ ] Engineer validates recommendations with checkComplexity()
- [ ] RECOMMENDATION.md includes Complexity Assessment section
- [ ] Over-engineering violations flagged with warnings (not blocked)
- [ ] Research identifies researchable gaps from DIAGNOSIS
- [ ] Research limited to 3 queries per session
- [ ] Research findings integrated into recommendation confidence
</success_criteria>

<output>
After completion, create `.planning/phases/15-polish-advanced-detection/15-04-SUMMARY.md`
</output>
