---
phase: 15-polish-advanced-detection
plan: 05
type: execute
wave: 3
depends_on: ["15-01", "15-02", "15-03", "15-04"]
files_modified:
  - lib/installer.js
  - test/integration/installer.test.js
  - test/integration/surveyor-integration.test.js
autonomous: true

must_haves:
  truths:
    - "New lib modules (complexity-ceiling.js, research-integration.js) are copied by installer"
    - "End-to-end flow works: survey with cliff signals triggers engineer takeover"
    - "Compound detection integrates with existing surveyor behavior"
    - "All new modules have installation tests"
  artifacts:
    - path: "test/integration/installer.test.js"
      provides: "Installation tests for new modules"
      contains: "complexity-ceiling"
    - path: "test/integration/surveyor-integration.test.js"
      provides: "Integration tests for cliff detection flow"
      contains: "compound"
  key_links:
    - from: "lib/installer.js"
      to: "lib/complexity-ceiling.js"
      via: "copies new lib files during installation"
      pattern: "cpSync.*lib"
    - from: "test/integration/surveyor-integration.test.js"
      to: "lib/cliff-detection.js"
      via: "tests compound detection in survey flow"
      pattern: "detectCompound"
---

<objective>
Complete Phase 15 with installer updates for new modules and comprehensive integration tests for the full cliff detection and engineer pipeline.

Purpose: Ensure all new functionality is properly installed and the end-to-end flow from survey with cliff signals through engineer document generation works correctly.

Output: Updated installer to copy new lib modules, integration tests verifying installation, and end-to-end tests for the complete cliff-to-engineer pipeline.
</objective>

<execution_context>
@/home/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/home/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-polish-advanced-detection/15-01-SUMMARY.md
@.planning/phases/15-polish-advanced-detection/15-02-SUMMARY.md
@.planning/phases/15-polish-advanced-detection/15-03-SUMMARY.md
@.planning/phases/15-polish-advanced-detection/15-04-SUMMARY.md

# Files to verify/modify
@lib/installer.js
@test/integration/installer.test.js
@test/integration/surveyor-integration.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify and Update Installer for New Modules</name>
  <files>lib/installer.js, test/integration/installer.test.js</files>
  <action>
Verify installer copies new lib modules and add installation tests.

**1. Check if installer already handles lib/ directory:**

The installer uses recursive cpSync for templates. Check if lib/ files are already handled:
- If lib/ is already in the copy manifest, no code changes needed
- If not, add lib/ to the installation targets

**2. Add installation tests for new modules:**

Add to test/integration/installer.test.js:

```javascript
describe('Phase 15 module installation', () => {
  it('installs complexity-ceiling.js to lib directory', async () => {
    // Run installer in test mode
    await runInstaller(['--claude', '--global'], { home: fakeHomeDir });

    // Verify file exists
    const filePath = path.join(fakeHomeDir, '.claude', 'lib', 'complexity-ceiling.js');
    assert.ok(fs.existsSync(filePath), 'complexity-ceiling.js should be installed');

    // Verify content structure
    const content = fs.readFileSync(filePath, 'utf-8');
    assert.ok(content.includes('COMPLEXITY_INDICATORS'), 'Should export COMPLEXITY_INDICATORS');
    assert.ok(content.includes('extractConstraints'), 'Should export extractConstraints');
    assert.ok(content.includes('checkComplexity'), 'Should export checkComplexity');
  });

  it('installs research-integration.js to lib directory', async () => {
    await runInstaller(['--claude', '--global'], { home: fakeHomeDir });

    const filePath = path.join(fakeHomeDir, '.claude', 'lib', 'research-integration.js');
    assert.ok(fs.existsSync(filePath), 'research-integration.js should be installed');

    const content = fs.readFileSync(filePath, 'utf-8');
    assert.ok(content.includes('identifyResearchableGaps'), 'Should export identifyResearchableGaps');
    assert.ok(content.includes('buildSearchQuery'), 'Should export buildSearchQuery');
  });

  it('installs updated cliff-detection.js with compound detection', async () => {
    await runInstaller(['--claude', '--global'], { home: fakeHomeDir });

    const filePath = path.join(fakeHomeDir, '.claude', 'lib', 'cliff-detection.js');
    assert.ok(fs.existsSync(filePath), 'cliff-detection.js should be installed');

    const content = fs.readFileSync(filePath, 'utf-8');
    assert.ok(content.includes('IMPLICIT_CLIFF_SIGNALS'), 'Should have implicit signals');
    assert.ok(content.includes('detectImplicitCliff'), 'Should export detectImplicitCliff');
    assert.ok(content.includes('detectCompound'), 'Should export detectCompound');
  });

  it('installs updated cliff-detection-signals.md config', async () => {
    await runInstaller(['--claude', '--global'], { home: fakeHomeDir });

    const filePath = path.join(fakeHomeDir, '.claude', 'config', 'cliff-detection-signals.md');
    assert.ok(fs.existsSync(filePath), 'cliff-detection-signals.md should be installed');

    const content = fs.readFileSync(filePath, 'utf-8');
    assert.ok(content.includes('Implicit Cliff Signals'), 'Should document implicit signals');
    assert.ok(content.includes('compound'), 'Should document compound detection');
  });
});
```

**3. Verify lib directory structure is correct:**

Ensure the following files exist in lib/:
- cliff-detection.js (updated with implicit + compound)
- complexity-ceiling.js (new)
- research-integration.js (new)

If installer doesn't copy lib/ files, this is a gap to address. Check 11-04-SUMMARY for how lib files were handled previously.

Note: Per decision in 11-04, installer already handles new files via recursive cpSync. The tests above verify the files are correctly copied with expected content.
  </action>
  <verify>npm test -- --test-name-pattern="Phase 15 module installation" passes all tests</verify>
  <done>Installer copies all new Phase 15 lib modules and tests verify correct installation</done>
</task>

<task type="auto">
  <name>Task 2: Add Integration Tests for Cliff Detection Flow</name>
  <files>test/integration/surveyor-integration.test.js</files>
  <action>
Add integration tests for the complete cliff detection flow.

**Add to test/integration/surveyor-integration.test.js:**

```javascript
import { detectExplicitCliff, detectImplicitCliff, detectCompound, IMPLICIT_CLIFF_SIGNALS } from '../../lib/cliff-detection.js';

describe('Cliff detection integration', () => {
  describe('Implicit signal detection', () => {
    it('detects hedging across signal categories', () => {
      const hedgingResponse = "Maybe we could use React, perhaps with Next.js";
      const result = detectImplicitCliff(hedgingResponse);

      assert.strictEqual(result.detected, true);
      assert.ok(result.signals.some(s => s.category === 'hedging'));
      assert.strictEqual(result.confidence, 'MEDIUM');
    });

    it('detects quality degradation markers', () => {
      const uncertainResponse = "Hmm, let me think... um, well...";
      const result = detectImplicitCliff(uncertainResponse);

      assert.strictEqual(result.detected, true);
      assert.ok(result.signals.some(s => s.category === 'quality_degradation'));
    });

    it('detects soft deferrals', () => {
      const deferralResponse = "Whatever works, you pick the database";
      const result = detectImplicitCliff(deferralResponse);

      assert.strictEqual(result.detected, true);
      assert.ok(result.signals.some(s => s.category === 'deferral'));
    });
  });

  describe('Compound detection threshold', () => {
    it('does not trigger on single implicit signal', () => {
      const singleSignalResponse = "Maybe PostgreSQL";
      const result = detectCompound(singleSignalResponse, []);

      assert.strictEqual(result.trigger, false);
      assert.strictEqual(result.signalCount, 1);
    });

    it('triggers when accumulating 2+ signals across responses', () => {
      const history = [
        { implicitSignals: [{ signal: 'maybe', category: 'hedging' }] }
      ];
      const currentResponse = "I guess that works";
      const result = detectCompound(currentResponse, history);

      assert.strictEqual(result.trigger, true);
      assert.strictEqual(result.reason, 'compound_implicit');
      assert.strictEqual(result.confidence, 'MEDIUM');
    });

    it('explicit signal overrides compound threshold', () => {
      const explicitResponse = "I don't know what database to use";
      const result = detectCompound(explicitResponse, []);

      assert.strictEqual(result.trigger, true);
      assert.strictEqual(result.reason, 'explicit_signal');
      assert.strictEqual(result.confidence, 'HIGH');
    });

    it('uses only last 3 responses from history', () => {
      // History with 5 responses, signals only in oldest 2
      const history = [
        { implicitSignals: [{ signal: 'maybe', category: 'hedging' }] },
        { implicitSignals: [{ signal: 'perhaps', category: 'hedging' }] },
        { implicitSignals: [] }, // -3
        { implicitSignals: [] }, // -2
        { implicitSignals: [] }  // -1
      ];
      // Current has 1 signal, history (last 3) has 0 = 1 total
      const result = detectCompound("Maybe", history);

      assert.strictEqual(result.trigger, false);
      assert.strictEqual(result.signalCount, 1); // Only current signal counts
    });
  });

  describe('Full survey simulation', () => {
    it('simulates gradual uncertainty accumulation', () => {
      const responses = [
        "I want to build a task management app",        // No signals
        "React seems good, maybe Next.js",              // 1 hedging
        "For the database, hmm, PostgreSQL I guess",    // 2 signals (quality + hedging)
        "Authentication... um, whatever works really"   // 3 signals (quality + deferral)
      ];

      const history = [];
      const results = [];

      for (const response of responses) {
        const implicitResult = detectImplicitCliff(response);
        const compoundResult = detectCompound(response, history);

        results.push({
          response: response.substring(0, 30) + '...',
          implicitSignals: implicitResult.signals.length,
          trigger: compoundResult.trigger,
          reason: compoundResult.reason,
          totalCount: compoundResult.signalCount
        });

        // Add to history for next iteration
        history.push({ implicitSignals: implicitResult.signals });
      }

      // First response: no trigger
      assert.strictEqual(results[0].trigger, false);

      // Second response: 1 signal, no trigger
      assert.strictEqual(results[1].trigger, false);

      // Third or fourth response should trigger (2+ accumulated)
      const triggered = results.some(r => r.trigger && r.reason === 'compound_implicit');
      assert.ok(triggered, 'Should trigger compound detection within 4 responses');
    });
  });
});
```
  </action>
  <verify>npm test -- --test-name-pattern="Cliff detection integration" passes all tests</verify>
  <done>Integration tests verify implicit detection, compound threshold, and simulated survey flow</done>
</task>

<task type="auto">
  <name>Task 3: Add Integration Tests for Complexity Ceiling</name>
  <files>test/integration/surveyor-integration.test.js</files>
  <action>
Add integration tests for complexity ceiling enforcement.

**Add to test/integration/surveyor-integration.test.js:**

```javascript
import { extractConstraints, checkComplexity } from '../../lib/complexity-ceiling.js';

describe('Complexity ceiling integration', () => {
  describe('Constraint extraction from survey', () => {
    it('extracts solo developer constraint', () => {
      const survey = {
        project: {
          name: 'TaskApp',
          one_liner: "A side project I'm building by myself"
        }
      };

      const constraints = extractConstraints(survey);

      assert.strictEqual(constraints.teamSize, 'solo');
      assert.strictEqual(constraints.maxComplexity, 'minimal');
    });

    it('extracts budget constraint from surveyor notes', () => {
      const survey = { project: { name: 'TaskApp' } };
      const surveyorNotes = {
        implicit_constraints: [
          "User mentioned wanting to stay on free tier",
          "Budget is a concern"
        ]
      };

      const constraints = extractConstraints(survey, surveyorNotes);

      assert.strictEqual(constraints.budget, 'constrained');
      assert.strictEqual(constraints.maxComplexity, 'minimal');
    });

    it('extracts MVP timeline', () => {
      const survey = {
        project: {
          name: 'TaskApp',
          one_liner: "Building an MVP to test the market"
        }
      };

      const constraints = extractConstraints(survey);

      assert.strictEqual(constraints.timeline, 'fast');
      assert.strictEqual(constraints.maxComplexity, 'minimal');
    });

    it('detects beginner experience', () => {
      const survey = { project: { name: 'TaskApp' } };
      const surveyorNotes = {
        implicit_constraints: [
          "This is my first time building a full-stack app"
        ]
      };

      const constraints = extractConstraints(survey, surveyorNotes);

      assert.strictEqual(constraints.experience, 'beginner');
    });
  });

  describe('Complexity ceiling enforcement', () => {
    it('allows any recommendation for standard complexity', () => {
      const constraints = { maxComplexity: 'standard' };
      const recommendations = [
        "Use microservices architecture",
        "Deploy on Kubernetes cluster",
        "Implement event-driven patterns"
      ];

      for (const rec of recommendations) {
        const result = checkComplexity(rec, constraints);
        assert.strictEqual(result.valid, true, `${rec} should be valid for standard`);
      }
    });

    it('flags over-engineering for minimal complexity', () => {
      const constraints = { maxComplexity: 'minimal' };

      const testCases = [
        { rec: "Use microservices", pattern: 'Microservice' },
        { rec: "Deploy on Kubernetes", pattern: 'K8s' },
        { rec: "Event-driven architecture", pattern: 'Event-driven' },
        { rec: "Build distributed system", pattern: 'Distributed' }
      ];

      for (const { rec, pattern } of testCases) {
        const result = checkComplexity(rec, constraints);
        assert.strictEqual(result.valid, false, `${rec} should be flagged`);
        assert.ok(
          result.violations.some(v => v.reason.includes(pattern)),
          `Should flag ${pattern}`
        );
      }
    });

    it('allows simple stack for minimal complexity', () => {
      const constraints = { maxComplexity: 'minimal' };
      const simpleRecommendations = [
        "Use Next.js with PostgreSQL",
        "Deploy on Vercel",
        "Use SQLite for local development",
        "Simple monolithic Node.js server"
      ];

      for (const rec of simpleRecommendations) {
        const result = checkComplexity(rec, constraints);
        assert.strictEqual(result.valid, true, `${rec} should be valid for minimal`);
      }
    });

    it('provides suggestions in violations', () => {
      const constraints = { maxComplexity: 'minimal' };
      const result = checkComplexity("Use Kubernetes", constraints);

      assert.ok(result.violations[0].suggestion);
      assert.ok(result.violations[0].suggestion.includes('monolithic'));
    });
  });

  describe('End-to-end constraint to ceiling flow', () => {
    it('detects MVP and enforces minimal ceiling', () => {
      // Simulate survey with MVP indicators
      const survey = {
        project: {
          name: 'TaskTracker',
          one_liner: "Quick MVP to validate idea before building full product"
        }
      };
      const surveyorNotes = {
        implicit_constraints: [
          "Just me working on this",
          "Want to ship fast"
        ]
      };

      // Extract constraints
      const constraints = extractConstraints(survey, surveyorNotes);
      assert.strictEqual(constraints.maxComplexity, 'minimal');

      // Validate recommendations
      const goodRec = checkComplexity("Use Next.js with Prisma and PostgreSQL", constraints);
      assert.strictEqual(goodRec.valid, true);

      const badRec = checkComplexity("Use microservices with Kubernetes and event sourcing", constraints);
      assert.strictEqual(badRec.valid, false);
      assert.ok(badRec.violations.length >= 2, 'Should flag multiple violations');
    });
  });
});
```
  </action>
  <verify>npm test -- --test-name-pattern="Complexity ceiling integration" passes all tests</verify>
  <done>Integration tests verify constraint extraction and complexity ceiling enforcement end-to-end</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run full test suite:
   ```bash
   npm test
   ```
   Expected: All tests pass including new Phase 15 tests

2. Count new tests added:
   ```bash
   npm test -- --test-name-pattern="Phase 15|Cliff detection integration|Complexity ceiling integration" 2>&1 | grep -c "ok\|pass"
   ```
   Expected: At least 20 new tests

3. Verify all lib files exist:
   ```bash
   ls -la lib/cliff-detection.js lib/complexity-ceiling.js lib/research-integration.js
   ```
   Expected: All three files exist

4. Run smoke test for full installation:
   ```bash
   npm test -- --test-name-pattern="smoke"
   ```
   Expected: Smoke test passes with all new files installed
</verification>

<success_criteria>
- [ ] Installer copies complexity-ceiling.js
- [ ] Installer copies research-integration.js
- [ ] Installer copies updated cliff-detection.js
- [ ] Installer copies updated cliff-detection-signals.md
- [ ] Installation tests verify all new files
- [ ] Integration tests for implicit signal detection pass
- [ ] Integration tests for compound detection pass
- [ ] Integration tests for complexity ceiling pass
- [ ] Full survey simulation test passes
- [ ] End-to-end constraint-to-ceiling test passes
- [ ] All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-polish-advanced-detection/15-05-SUMMARY.md`
</output>
